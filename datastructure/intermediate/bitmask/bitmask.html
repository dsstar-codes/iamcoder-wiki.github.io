<!DOCTYPE HTML>
<html lang="ko" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Bitmask - IamCoder Wiki</title>
        
        

        <!-- Custom HTML head -->
        


        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="IamCoder Wiki">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        
        <link rel="icon" href="/favicon.svg">
        
        
        <link rel="shortcut icon" href="/favicon.png">
        
        <link rel="stylesheet" href="/css/variables.css">
        <link rel="stylesheet" href="/css/general.css">
        <link rel="stylesheet" href="/css/chrome.css">
        <link rel="stylesheet" href="/css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="/FontAwesome/css/font-awesome.css">
        
        <link rel="stylesheet" href="/fonts/fonts.css">
        

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="/highlight.css">
        <link rel="stylesheet" href="/tomorrow-night.css">
        <link rel="stylesheet" href="/ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        

        
        <!-- MathJax -->
        <script async type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
        
    </head>
    <body>
        <!-- Provide site root to javascript -->
        <script type="text/javascript">
            var path_to_root = "/";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light (default)</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                        
                    </div>

                    <h1 class="menu-title"><a href="/" style="text-decoration:none;"><p class="menu-title-anchor">IamCoder Wiki</p></a></h1>

                    <div class="right-buttons">
                        <a href="/print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        
                        <a href="https://github.com/iamcoder-wiki/iamcoder-wiki.github.io" title="Git repository" aria-label="Git repository">
                            <i id="git-repository-button" class="fa fa-github"></i>
                        </a>
                        
                    </div>
                </div>

                
                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" name="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>
                

                <div id="content" class="content">
                    <main>
                        
<script>
function sleep(ms) {
  return new Promise(resolve => setTimeout(resolve, ms));
}

async function writeTitle() {
    let s = ["B_", "Bi_", "Bit_", "Bitm_", "Bitma_", "Bitmas_", "Bitmask_", "Bitmask_", "Bitmask_", "Bitmask_", "Bitmask", "Bitmask", "Bitmask", "Bitmask", "Bitmask_", "Bitmask_", "Bitmask_", "Bitmask_", "Bitmask"];
    let title = document.getElementsByClassName('title')[0];
    for(let i in s) {
        title.innerHTML = s[i];
        await sleep(100);
    }
}

window.onload = function() {
    writeTitle();
}
</script><h1><a class="header title" href="#bitmask" id="bitmask">_</a></h1>
<h2><a class="header" href="#소개" id="소개">1. 소개</a></h2>
<p>그럼 이제 본격적으로 비트마스킹이 뭔지 설명할 차례입니다. 비트마스킹에는 <a href="../bitoperator/bitoperator">비트 연산자</a>가 모든 연산을 차지합니다. 먼저 비트마스크(Bitmask)의 정의부터 살펴봅시다. 비트마스크란, 비트를 변경하여 정보를 저장하는 정수를 뜻합니다. 비트마스킹 기법은 이 비트마스크를 사용하여 메모리 및 연산속도를 대폭 줄일 수 있습니다.</p>
<h2><a class="header" href="#장점" id="장점">2. 장점</a></h2>
<p>비트마스크는 다음과 같은 주요 장점이 있습니다.</p>
<ul>
<li>
<p><strong>메모리 사용량의 큰 단축</strong></p>
<p>비트마스크는 하나의 bool연산자를 하나의 비트로 대체할 수 있습니다. 실제 하나의 int형 정수는 32비트이므로, bool 연산자 32개(\(2 \times 32 = 64\)(byte))를 int형 정수 1개(4(byte))로 줄일 수 있습니다. 그렇게 함으로써, 긴 bool 배열을 짧은 정수배열로 바꾸어 메모리를 16배 가량 줄일 수 있게 해줍니다.</p>
</li>
<li>
<p><strong>실행시간의 단축</strong></p>
<p>실제로 연산 <code>4 * 2</code>와 <code>4 &lt;&lt; 1</code>은 차이가 눈에 띄게 있지 않습니다. 그러나 이 연산이 몇천번정도 반복된다면 이야기가 달라집니다. 일반적인 사칙연산은 비트연산을 여러번 진행한 다음 그 결과값을 반환하지만 비트연산은 딱 한번의 연산만 필요하기 때문에 실행시간을 많게는 반 가량 단축시킬 수 있습니다.</p>
</li>
<li>
<p><strong>코드 길이의 단축</strong></p>
<p>비트마스크를 쓸 경우 복잡한 코드가 한주로 짧게 줄어들 수 있습니다. 비트마스킹만 잘 안다면, 코드의 가독성이 향상될 것입니다.</p>
</li>
</ul>
<h2><a class="header" href="#코드" id="코드">3. 코드</a></h2>
<p>비트마스킹으로 배열에 있는 많은 기능들을 구현해 봅시다. 대부분의 구현들이 간단한 비트연산 한번으로 가능합니다. 다음 코드를 봅시다.</p>
<pre><code class="language-c++">#include &lt;bits/stdc++.h&gt; 

int Bitmask;

int main(){
    Bitmask = 10; //이진수로 1010
    int n, tmp = Bitmask;
    scanf(&quot;%d&quot;, &amp;n);
    if(Bitmask &amp; (1 &lt;&lt; n)) printf(&quot;arr[%d] is true.\n&quot;, n); //원소의 존재 확인, 저기서 1과 같냐는 조건을 추가한다면 제대로 동작하지 않습니다.
    
    scanf(&quot;%d&quot;, &amp;n);
    Bitmask |= (1 &lt;&lt; n); //원소 추가
    printf(&quot;%dth(st, nd, rd) element added.\n&quot;, n);
  
    scanf(&quot;%d&quot;, &amp;n);
    Bitmask &amp;= ~(1 &lt;&lt; n); //원소 삭제, 만약 원소가 없으면 그대로
    printf(&quot;%dth(st, nd, rd) element deleted.(if in array)&quot;, n);
    
    scanf(&quot;%d&quot;, &amp;n);
    Bitmask ^= (1 &lt;&lt; n); //원소 토글, if문이 필요 없습니다.
    printf(&quot;%dth(st, nd, rd) element toggled.&quot;, n);

    int Union = (Bitmask | tmp); //합집합, for문 불필요
    
    int Intersection = (Bitmask &amp; tmp); //교집합
    
    int Relative_Component = (Bitmask &amp; ~tmp); //차집합
    
    int Symmetric_Difference = (Bitmask ^ tmp) //대칭차집합
    
    int Complement_Set = ~Bitmask //여집합

    int Min_element = (Bitmask &amp; -Bitmask); //최소원소

    Bitmask &amp;= (Bitmask - 1); //최소원소 지우기

    for(int Sub = Bitmask, i = 1; Sub; Sub = ((Sub - 1) &amp; Bitmask), i++){
        printf(&quot;Subset %d: %d&quot;, i, Sub); //모든 부분집합 순회
    }

    //비트마스킹을 사용할 때는 모든 비트 연산의 주변에 괄호를 치는 것을 추천합니다. 잘못하면 연산자 우선순위 때문에 어이없는 오류가 날 수도 있기 떄문입니다.

}
</code></pre>
<h2><a class="header" href="#코드-설명" id="코드-설명">4. 코드 설명</a></h2>
<p>차근차근 짚어나가 보죠.</p>
<h3><a class="header" href="#원소-확인" id="원소-확인">4.1. 원소 확인</a></h3>
<p>원소 확인은 쉬프트 연산을 통해 1비트의 자리를 설정하고, AND연산을 하여 0인지 0이 아닌 다른 값인지 확인해 줍니다. 이떄, AND연산의 결과가 꼭 1은 아닙니다. 왜냐하면 AND연산은 참 거짓이 아닌 계산의 결과값, 즉 그 자리에 비트가 있다면 2의 거듭제곱을 반환하기 떄문입니다. </p>
<h3><a class="header" href="#원소-추가" id="원소-추가">4.2. 원소 추가</a></h3>
<p>OR연산을 통해 원소를 추가해 줍니다. 설령 이미 원소가 있더라도, 원소는 다르게 바뀌지 않습니다. 있으면 항상 1이기 때문에 1이 1로 바뀌는 것일 뿐입니다. 즉, 변화가 없습니다. </p>
<h3><a class="header" href="#원소-삭제" id="원소-삭제">4.3. 원소 삭제</a></h3>
<p>AND연산을 통해 원소를 삭제해 줍니다. 삭제할 위치의 비트만 1인 상태에서 NOT연산을 취해 준다면 비트가 반전되어 그 비트만 삭제됩니다. 설령 원소가 이미 없더라도 괜찮습니다. 마찬가지로 0이 그대로 0으로 갱신되는 것 뿐입니다. </p>
<h3><a class="header" href="#원소-반전토글" id="원소-반전토글">4.4. 원소 반전(토글)</a></h3>
<p>XOR연산으로 원소를 토글해줍니다. 원소가 1이면 0으로, 0이면 1으로 바꿔준다는 것을 쉽게 알 수 있습니다. 여기서 눈여겨봐야 할 점은, 조건문이 전혀 필요없다는 것입니다. 비트연산 하나로 간단하게 끝낼 수 있다는 점, 이게 바로 비트마스킹의 장점입니다. </p>
<h3><a class="header" href="#합집합" id="합집합">4.5. 합집합</a></h3>
<p>두 집합 사이 OR연산으로 원소가 둘 중 한곳이라도 있다면 전부 있음으로 표시하여 합집합을 계산합니다. </p>
<h3><a class="header" href="#교집합" id="교집합">4.6. 교집합</a></h3>
<p>두 집합 사이 AND연산으로 원소가 두 곳 모두 있다면 있음으로 표시하여 교집합을 계산합니다. </p>
<h3><a class="header" href="#차집합" id="차집합">4.7. 차집합</a></h3>
<p>한 집합을 비트반전(NOT) 반전한 다음 AND 연산으로 원소가 반전한 집합과 반전하지 않은 집합 둘 다 있다면 전부 있음으로 표시하여 차집합을 계산합니다. </p>
<h3><a class="header" href="#대칭차집합" id="대칭차집합">4.8. 대칭차집합</a></h3>
<p>두 집합 사이 XOR연산으로 원소의 유무가 다르다면 전부 있음으로 표시하여 대칭차집합을 계산합니다. </p>
<h3><a class="header" href="#여집합" id="여집합">4.9. 여집합</a></h3>
<p>NOT연산으로 원소를 반전하여 여집합을 계산합니다.</p>
<h3><a class="header" href="#최소-원소-찾기" id="최소-원소-찾기">4.10. 최소 원소 찾기</a></h3>
<p>최소원소 찾기는 비트마스킹의 장점을 다시 한번 보여주는 좋은 예입니다. 위 식은 보수를 이용한 것으로, 보수가 <code>-N-1</code>으로 표현가능함을 이용하여 가장 작은 원소를 손쉽게 계산할 수 있습니다.</p>
<p>또한, 1을 빼면 최소원소 직전의 0들은 모두 1로 반전되고 최소비트 하나만 0으로 반전되기 떄문에 최소비트를 빠르게 뺄 수 있습니다. 최소 원소를 구하고 반전시키는 것보다 훨씬 빠릅니다. </p>
<h3><a class="header" href="#시간복잡도" id="시간복잡도">4.11. 시간복잡도</a></h3>
<p>여기까지 모든 연산의 시간복잡도는 모두 \(O(1)\)입니다.</p>
<h3><a class="header" href="#부분집합-순회" id="부분집합-순회">4.12. 부분집합 순회</a></h3>
<p>마지막으로 부분집합 순회입니다. 저 순회는 다른거에 비해 굉장히 강력합니다. 매우 간단하게 모든 부분집합을 탐색하는 코드를 만들 수 있기 떄문이죠. 먼저 1을 뺀다면 최하위 비트와 그 밑의 0들은 전부 반전됩니다. 그 후 원래 집합과의 교집합을 구한다면, 그 원집합에 속하지 않는 원소들은 모두 꺼지게 됩니다. 그리하여 모든 부분집합을 탐색해나갈 수 있습니다.</p>
<p>시간복잡도는 \(O(2^{N})\)입니다.</p>
<h2><a class="header" href="#예제" id="예제">5. 예제</a></h2>
<p>비트마스킹은 주로 동적계획법, 즉 다이나믹 프로그래밍과 같이 자주 쓰입니다. 다음 예제를 봅시다. 이 문제는 백준 OJ의 <a href="https://www.acmicpc.net/problem/2098">외판원 순회</a> 문제입니다.</p>
<blockquote>
<p>외판원 순회 문제는 영어로 Traveling Salesman problem (TSP) 라고 불리는 문제로 computer science 분야에서 가장 중요하게 취급되는 문제 중 하나이다. 여러 가지 변종 문제가 있으나, 여기서는 가장 일반적인 형태의 문제를 살펴보자.</p>
<p>1번부터 N번까지 번호가 매겨져 있는 도시들이 있고, 도시들 사이에는 길이 있다. (길이 없을 수도 있다) 이제 한 외판원이 어느 한 도시에서 출발해 N개의 도시를 모두 거쳐 다시 원래의 도시로 돌아오는 순회 여행 경로를 계획하려고 한다. 단, 한 번 갔던 도시로는 다시 갈 수 없다. (맨 마지막에 여행을 출발했던 도시로 돌아오는 것은 예외) 이런 여행 경로는 여러 가지가 있을 수 있는데, 가장 적은 비용을 들이는 여행 계획을 세우고자 한다.</p>
<p>각 도시간에 이동하는데 드는 비용은 행렬 <code>W[i][j]</code>형태로 주어진다. <code>W[i][j]</code>는 도시 <code>i</code>에서 도시 <code>j</code>로 가기 위한 비용을 나타낸다. 비용은 대칭적이지 않다. 즉, <code>W[i][j]</code> 는 <code>W[j][i]</code>와 다를 수 있다. 모든 도시간의 비용은 양의 정수이다. <code>W[i][i]</code>는 항상 0이다. 경우에 따라서 도시 <code>i</code>에서 도시 <code>j</code>로 갈 수 없는 경우도 있으며 이럴 경우 <code>W[i][j] = 0</code>이라고 하자.</p>
<p>N과 비용 행렬이 주어졌을 때, 가장 적은 비용을 들이는 외판원의 순회 여행 경로를 구하는 프로그램을 작성하시오.</p>
<hr />
<p><strong>입력</strong></p>
<p>첫째 줄에 도시의 수 <code>N</code>이 주어진다. (\(2 \leq N \leq 16)\) 다음 <code>N</code>개의 줄에는 비용 행렬이 주어진다. 각 행렬의 성분은 1,000,000 이하의 양의 정수이며, 갈 수 없는 경우는 0이 주어진다. <code>W[i][j]</code>는 도시 <code>i</code>에서 <code>j</code>로 가기 위한 비용을 나타낸다.</p>
<p>항상 순회할 수 있는 경우만 입력으로 주어진다.</p>
<hr />
<p><strong>출력</strong></p>
<p>첫째 줄에 외판원의 순회에 필요한 최소 비용을 출력한다.</p>
<hr />
<p><strong>입출력 예시</strong></p>
<hr />
<p><em><strong>Input</strong></em></p>
<p><em>4</em></p>
<p><em>0 10 15 20</em></p>
<p><em>5  0  9 10</em></p>
<p><em>6 13  0 12</em></p>
<p><em>8  8  9  0</em></p>
<hr />
<p><em><strong>Output</strong></em></p>
<p><em>35</em></p>
</blockquote>
<p>이 문제의 풀이 방법은 비트마스크와 다이나믹 프로그래밍입니다. 먼저 시작 도시를 정한 후, 그 도시로 부터 갈 수 있는 방법을 완전탐색 해 나갑니다. 이떄, 그냥 일반적인 완전탐색은 시간이 엄청나게 오래 걸리므로, 다이나믹 프로그래밍을 사용합니다. 점화식은 다음과 같습니다.</p>
<p>\(TSP(curr, visited) = min(TSP(next, visited \cup next) + dist[curr][next]) \)</p>
<p>\((0 \leq next \leq N - 1, next \neq curr, next \notin visited)\)</p>
<p>현재 도시의 순회 최솟값을 알기 위해 다음 돌아가는 모든 경로를 탐색한 후 그 값을 DP에 저장하면 문제가 풀릴 수 있습니다. 이떄, 집합 visited를 비트마스킹으로 구현할 수 있습니다.</p>
<p>이 코드는 DP의 원소의 개수가 \(2^{N} \times N\)이고 이를 각 도시마다 한 번씩 N번 탐색하여 총 시간복잡도는 \(O(2^{N} \times N^{2})\)입니다. 만약 다이나믹기법을 쓰지 않았다면 모두 일일이 탐색해야 하므로 시간복잡도는 \(O(N!)\)이 되었을 것입니다. 느리기는 하지만, 확실히 빨라졌습니다. 여기에 비트마스킹으로 연산속도까지 빨라졌으니, 문제에서 주어진 <code>N</code>의 범위쯤은 거뜬합니다.</p>

                    </main>
                </div>
            </div>

        </div>

        

        
        <!-- Google Analytics Tag -->
        <script type="text/javascript">
            var localAddrs = ["localhost", "127.0.0.1", ""];

            // make sure we don't activate google analytics if the developer is
            // inspecting the book locally...
            if (localAddrs.indexOf(document.location.hostname) === -1) {
                (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
                (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
                m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
                })(window,document,'script','https://www.google-analytics.com/analytics.js','ga');

                ga('create', 'UA-174669347-1', 'auto');
                ga('send', 'pageview');
            }
        </script>
        

        

        
        <script type="text/javascript">
            window.playground_copyable = true;
        </script>
        

        

        
        <script src="/elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="/mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="/searcher.js" type="text/javascript" charset="utf-8"></script>
        

        <script src="/clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="/highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="/book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->
        

        

    </body>
</html>
