<!DOCTYPE HTML>
<html lang="ko" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>IamCoder Wiki</title>
        
        <meta name="robots" content="noindex" />
        
        

        <!-- Custom HTML head -->
        


        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="IamCoder Wiki">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        
        <link rel="icon" href="favicon.svg">
        
        
        <link rel="shortcut icon" href="favicon.png">
        
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        
        <link rel="stylesheet" href="fonts/fonts.css">
        

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        

        
        <!-- MathJax -->
        <script async type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
        
    </head>
    <body>
        <!-- Provide site root to javascript -->
        <script type="text/javascript">
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light (default)</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                        
                    </div>

                    <h1 class="menu-title"><a href="" style="text-decoration:none;"><p class="menu-title-anchor">IamCoder Wiki</p></a></h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        
                        <a href="https://github.com/iamcoder-wiki/iamcoder-wiki.github.io" title="Git repository" aria-label="Git repository">
                            <i id="git-repository-button" class="fa fa-github"></i>
                        </a>
                        
                    </div>
                </div>

                
                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" name="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>
                

                <div id="content" class="content">
                    <main>
                        <script>
function sleep(ms) {
  return new Promise(resolve => setTimeout(resolve, ms));
}

async function writeTitle() {
    let s = ['i_', 'ia_', 'iam_', 'iamc_', 'iamco_', 'iamcod_', 'iamcode_', 
    'iamcoder_', 'iamcoder:_', 'iamcoder:ㄷ_', 'iamcoder:대_', 'iamcoder:대ㅁ_', 
    'iamcoder:대무_', 'iamcoder:대문_', 'iamcoder:대문_', 'iamcoder:대문_', 
    'iamcoder:대문_', 'iamcoder:대문', 'iamcoder:대문', 'iamcoder:대문', 'iamcoder:대문',
    'iamcoder:대문_', 'iamcoder:대문_', 'iamcoder:대문_', 'iamcoder:대문_', 
    'iamcoder:대문'];
    for(let i in s) {
        document.getElementById('title').innerHTML = s[i];
        await sleep(100);
    }
}

window.onload = writeTitle;
</script>
<h1 id="title">_</h1>
<p>안녕하세요. IamCoder(나는코더다) 위키입니다.</p>
<h2><a class="header" href="#소개" id="소개">1. 소개</a></h2>
<ul>
<li><a href="./intro/site.html">사이트 소개</a></li>
<li><a href="./intro/iamcoder/iamcoder.html">IamCoder</a></li>
</ul>
<h2><a class="header" href="#알고리즘" id="알고리즘">2. 알고리즘</a></h2>
<ul>
<li><a href="./algorithm/sort/sort.html">Sort</a></li>
<li><a href="./algorithm/graphtraversal/graphtraversal.html">Graph Traversal</a></li>
<li><a href="./algorithm/divideandconquer/divideandconquer.html">Divide &amp; Conquer</a></li>
<li><a href="./algorithm/dp/dp.html">Dynamic Programming</a></li>
<li><a href="./algorithm/shortestpath/shortestpath.html">Shortest Path</a></li>
<li><a href="./algorithm/query/query.html">Query Technique</a></li>
<li><a href="./algorithm/dpopt/dpopt.html">DP Optimization</a></li>
<li><a href="./algorithm/networkflow/networkflow.html">Network Flow</a></li>
<li><a href="./algorithm/geometry/geometry.html">Geometry</a></li>
<li><a href="./algorithm/string/string.html">String</a></li>
</ul>
<h2><a class="header" href="#자료구조" id="자료구조">3. 자료구조</a></h2>
<ul>
<li><a href="./datastructure/basic/basic.html">Basic</a></li>
<li><a href="./datastructure/intermediate/intermediate.html">Intermediate</a></li>
<li><a href="./datastructure/tree/tree.html">Tree</a></li>
<li><a href="./datastructure/segmenttree/segmenttree.html">Segment Tree</a></li>
<li><a href="./datastructure/advanced/advanced.html">Advanced</a></li>
</ul>
<h2><a class="header" href="#기타" id="기타">4. 기타</a></h2>
<ul>
<li><a href="./additional/additional.html">Additional Topics</a></li>
</ul>
<h2><a class="header" href="#problem-solving" id="problem-solving">5. Problem Solving</a></h2>
<ul>
<li><a href="./ps/oi/oi.html">OI</a></li>
<li><a href="./ps/site.html">SITE</a></li>
</ul>
<h1><a class="header" href="#tutorial" id="tutorial">Tutorial</a></h1>
<h2><a class="header" href="#소개-1" id="소개-1">1. 소개</a></h2>
<ul>
<li><a href="./intro/site.html">사이트 소개</a></li>
<li><a href="./intro/iamcoder/iamcoder.html">IamCoder</a></li>
</ul>
<h2><a class="header" href="#알고리즘-1" id="알고리즘-1">2. 알고리즘</a></h2>
<ul>
<li><a href="./algorithm/sort/sort.html">Sort</a></li>
<li><a href="./algorithm/graphtraversal/graphtraversal.html">Graph Traversal</a></li>
<li><a href="./algorithm/divideandconquer/divideandconquer.html">Divide &amp; Conquer</a></li>
<li><a href="./algorithm/dp/dp.html">Dynamic Programming</a></li>
<li><a href="./algorithm/shortestpath/shortestpath.html">Shortest Path</a></li>
<li><a href="./algorithm/query/query.html">Query Technique</a></li>
<li><a href="./algorithm/dpopt/dpopt.html">DP Optimization</a></li>
<li><a href="./algorithm/networkflow/networkflow.html">Network Flow</a></li>
<li><a href="./algorithm/geometry/geometry.html">Geometry</a></li>
<li><a href="./algorithm/string/string.html">String</a></li>
</ul>
<h2><a class="header" href="#자료구조-1" id="자료구조-1">3. 자료구조</a></h2>
<ul>
<li><a href="./datastructure/basic/basic.html">Basic</a></li>
<li><a href="./datastructure/intermediate/intermediate.html">Intermediate</a></li>
<li><a href="./datastructure/tree/tree.html">Tree</a></li>
<li><a href="./datastructure/segmenttree/segmenttree.html">Segment Tree</a></li>
<li><a href="./datastructure/advanced/advanced.html">Advanced</a></li>
</ul>
<h2><a class="header" href="#기타-1" id="기타-1">4. 기타</a></h2>
<ul>
<li><a href="./additional/additional.html">Additional Topics</a></li>
</ul>
<h2><a class="header" href="#problem-solving-1" id="problem-solving-1">5. Problem Solving</a></h2>
<ul>
<li><a href="./ps/oi/oi.html">OI</a></li>
<li><a href="./ps/site.html">SITE</a></li>
</ul>
<h1><a class="header" href="#사이트-소개" id="사이트-소개">사이트 소개</a></h1>
<p>이 사이트는 정보과학을 공부하고, 알고리즘을 공부하는 학생들을 위해 만든 사이트입니다.</p>
<ul>
<li>
<p>기본적으로 이 사이트는 사용자가 읽고, 수정하기 쉽도록 하기 위해 위키 구조를 갖고 있습니다.</p>
</li>
<li>
<p>정보과학을 공부하는 사람은 누구나 사이트를 통해서 도움을 받고 공부를 할 수 있지만, 사이트의 수정 권한은 <a href="intro/iamcoder/iamcoder.html">IamCoder</a> 부원들에게 있습니다.</p>
</li>
<li>
<p>사이트의 내용은 원래 책을 쓰기 위해 만들어졌기 때문에 선형으로 되어 있었으나 위키 형태로 만드는 과정에서 상위/하위 문서를 갖는 트리가 되었습니다. 트리의 루트는 <a href="intro/./tutorial.html">Tutorial</a>입니다.</p>
</li>
</ul>
<h1><a class="header" href="#iamcoder-소개" id="iamcoder-소개">IamCoder 소개</a></h1>
<p>경기과학고등학교 정보과학 동아리 IamCoder입니다.</p>
<ul>
<li><a href="intro/iamcoder/./fix.html">How to Add / Fix Document?</a></li>
</ul>
<h1><a class="header" href="#how-to-add--fix-document" id="how-to-add--fix-document">How to Add / Fix Document?</a></h1>
<h2><a class="header" href="#규칙" id="규칙">1. 규칙</a></h2>
<ul>
<li>문서는 보통 <em>소개</em> -&gt; <em>내용 (코드, 하위 내용)</em> -&gt; <em>예시(관련 문제, 해답)</em> -&gt; <em>관련 문서 (없으면 생략)</em> -&gt; <em>여담(팁, 응용, 등 / 없으면 생략)</em> 순으로 진행된다.</li>
<li>관련된 상위 문서 / 하위 문서와 연결하여 문서를 추가한다.</li>
<li>어떤 문제에 대한 해답을 적을 때, __대부분__의 경우(<em>매우 쉬운 문제 제외</em>) 답안 코드를 적지 않고 답의 아이디어나 코딩 팁 정도만 적는다.</li>
</ul>
<h2><a class="header" href="#markdown" id="markdown">2. Markdown</a></h2>
<ul>
<li>
<p><a href="https://theorydb.github.io/envops/2019/05/22/envops-blog-how-to-use-md/">이런 사이트</a>에서 기본적인 정보를 얻을 수 있음</p>
</li>
<li>
<p>페이지의 가장 첫 제목은 <code>#</code>으로 표현하고 하위 제목들은 <code>#</code>의 개수 2개, 3개, ... , 6개 순으로 늘리면 됨</p>
<ul>
<li>넘버링은 알아서 해주니 <code>#</code> 개수로 하위 제목 표현만 해주면 됨</li>
</ul>
<blockquote>
<p>ex)</p>
<pre><code>### hello
#### hello?
#### world?
### world
</code></pre>
<h3><a class="header" href="#hello" id="hello">2.1. hello</a></h3>
<h4><a class="header" href="#hello-1" id="hello-1">2.1.1. hello?</a></h4>
<h4><a class="header" href="#world" id="world">2.1.2. world?</a></h4>
<h3><a class="header" href="#world-1" id="world-1">2.2. world</a></h3>
</blockquote>
</li>
<li>
<p>어떤 __수식__을 문장 내부에 넣고 싶으면 <code>\\(</code>  수식 <code>\\)</code>  형태로 latex에 사용하던 수식들을<code> $  $</code> 대신 <code>\\(</code> 랑<code> \\)</code>로 감싸면 됨</p>
<ul>
<li>한줄 전체에 수식을 넣는 경우 <code>$$ comment $$</code> 로 처리 가능</li>
</ul>
<blockquote>
<p>ex)</p>
<pre><code>\\( N \leq 10 \\)
</code></pre>
<p>\( N \leq 10 \)</p>
</blockquote>
</li>
<li>
<p>__코드__는 <code>``` c++</code> 로 시작해서 한줄 띄우고 코드 작성 후 <code> ```</code>  를 마지막 줄에 넣으면 됨 </p>
<blockquote>
<p>ex)</p>
<pre><code>​``` c++
#include &lt;stdio.h&gt;

int main(){
printf(&quot;hello world&quot;);
return 0;
}
​```
</code></pre>
<pre><code class="language-c++">#include &lt;stdio.h&gt;

int main(){
printf(&quot;hello world&quot;);
return 0;
}
</code></pre>
</blockquote>
</li>
<li>
<p>__인용 표현__은 첫줄과 마지막 줄에 <code>&gt;</code>를 쓰면 되고, 인용 내부에서 또 인용은 <code>&gt;</code>의 개수를 2개, 3개 순으로 늘리면 됨. 문제 적을때 인용 표현 내부에 문제, 입력, 출력 순으로 적으면 됨 (<a href="intro/iamcoder/../../datastructure/intermediate/bitmask/bitmask.html">bitmask 문서</a> 마지막 예제 부분 참고)</p>
<blockquote>
<p>ex)</p>
<pre><code>&gt;
hello 
world
&gt;
</code></pre>
<blockquote>
<p>hello 
world</p>
</blockquote>
</blockquote>
</li>
<li>
<p>html은 그냥 넣으면 들어간다고 함... 그래서 javascript로 애니메이션을 넣거나 할수 있다고 함...</p>
<ul>
<li>youtube embedding 가능</li>
<li>주석을 처리 가능 <code>&lt;!-- comment --&gt;</code></li>
</ul>
</li>
</ul>
<h1><a class="header" href="#sort" id="sort">Sort</a></h1>
<h2><a class="header" href="#sort정렬이란" id="sort정렬이란">1. Sort(정렬)이란?</a></h2>
<p>프로그래밍에서 정렬이란 무작위로 있는 여러 자료들의 순서를 규칙성 있게 재배열하는 것을 뜻한다. 오름차순, 또는 내림차순으로 정렬하는 것이 일반적이나, 내가 임의로 정한 규칙에 따라 정렬해야 하는 경우도 있다. 정렬해야 하는 자료들의 개수가 <code>n</code>일 때, 정렬알고리즘은 크게 시간복잡도가 \(O(n^2)\), \(O(n\log n)\)과 그 이외인 것으로 나뉘는데, 초급단계에서는 이 \(O(n^2)\) 방법만 알아도 큰 무리는 없다. 구현이 5에서 6줄 정도로 매우 짧고 개념도 직관적으로 이해가 쉽기 때문이다. 그러나 중급단계 이상에서는 100000개 이상의 자료들을 정렬해야 하는 경우가 생겨 \(O(n^2)\)방법으로는 시간초과가 나게 된다. 따라서 \(O(nlogn)\)정렬을 기용해야 하는데, 구현이 모두 \(20\)줄 이상으로 생각보다 쉽지만은 않다. 그러나 우리에게는 하나의 무기가 있는데, 그게 뭔지는 차차 알아가 보도록 하자. 이제부터 설명을 시작할 건데, 이하의 예시코드는 다음의 함수 <code>sortarr()</code> 안에 들어갈 코드로 하자. <code>n</code>개의 <code>int</code>형 자료를 오름차순으로 정렬하여 순서대로 출력하는 프로그램을 다음과 같이 구현하자.</p>
<pre><code class="language-c++">#include &lt;bits/stdc++.h&gt;
using namespace std;
int arr[100010], n;
int main()  
{
    scanf(&quot;%d&quot;, &amp;n);
    for(int i=1; i&lt;=n; i++)
        scanf(&quot;%d&quot;, &amp;arr[i]);
    sortarr();  //여기
    for(int i=1; i&lt;=n; i++)
        printf(&quot;%d &quot;, arr[i]);
}
</code></pre>
<h2><a class="header" href="#-on2--sort" id="-on2--sort">2. \( O(n^2) \) Sort</a></h2>
<h3><a class="header" href="#종류" id="종류">2.1. 종류</a></h3>
<ul>
<li><a href="algorithm/sort/./bubblesort.html">Bubble Sort</a></li>
<li><a href="algorithm/sort/./selectionsort.html">Selection Sort</a></li>
<li><a href="algorithm/sort/./insertionsort">Insertion Sort</a></li>
</ul>
<h3><a class="header" href="#여담" id="여담">2.2. 여담</a></h3>
<p>이로써 기본적인 정렬 알고리즘들을 살펴보았는데, 이 알고리즘들은 정렬할 때 쓰일 뿐만 아니라 문제에도 활용이 되는 기본 중의 기본으로 꼭 익혀둬야 한다. 앞으로의 \(O(n\log n)\) 알고리즘들은 더욱 심화된 자료구조와 기법을 사용하므로 모르는 자료구조가 있으면 같은 책의 앞 또는 뒤에 설명이 있으므로 참고하면 되고, 인터넷에서도 설명이 친절하게 되어 있으니 참고하길 바란다.</p>
<h2><a class="header" href="#onlog-n-sort" id="onlog-n-sort">3. \(O(n\log n)\) Sort</a></h2>
<h3><a class="header" href="#종류-1" id="종류-1">3.1. 종류</a></h3>
<ul>
<li><a href="algorithm/sort/./mergesort">Merge Sort</a></li>
<li><a href="algorithm/sort/./heapsort">Heap Sort</a></li>
<li><a href="algorithm/sort/./quicksort">Quick Sort</a></li>
</ul>
<h2><a class="header" href="#기타-정렬" id="기타-정렬">4. 기타 정렬</a></h2>
<h3><a class="header" href="#종류-2" id="종류-2">4.1. 종류</a></h3>
<ul>
<li><a href="algorithm/sort/./countingsort">Counting Sort</a></li>
<li><a href="algorithm/sort/./radixsort">Radix Sort</a></li>
<li><a href="algorithm/sort/./introsort">Intro Sort</a></li>
</ul>
<h2><a class="header" href="#여담-1" id="여담-1">5. 여담</a></h2>
<h1><a class="header" href="#bubble-sort" id="bubble-sort">Bubble Sort</a></h1>
<h2><a class="header" href="#소개-2" id="소개-2">1. 소개</a></h2>
<p>\(O(n^2)\)정렬 중에서 구현이 제일 쉽고 유명한 방법이다. 인접한 두개의 항의 대소를 비교하여 작은 것을 앞으로 보내는 방법이다. 이 방법의 정당성은 이해하기 쉽다. <code>(1, 2), (2, 3), … ,(n-1, n)</code> 번을 순차적으로 비교했을 때, 다른 것은 모르지만 <code>n</code>번째 원소의 값이 최대라는 것은 확신할 수 있다. 이를 <code>n</code>번 반복하여 뒤에서부터 올바르게 숫자를 채워나간다면 정렬이 완료될 것이다. 이를 <code>for</code>문 두개를 이용하여 구현할 수 있고, 총 연산이 \(n*(n-1)/2\)번 실행되므로 시간복잡도는 \(O(n^2)\)이다.</p>
<h2><a class="header" href="#코드" id="코드">2. 코드</a></h2>
<pre><code class="language-c++">void sortarr()
{
    for(int i=1; i&lt;n; i++)
        for(int j=1; j&lt;=n-i; j++)
            if(arr[j]&gt;arr[j+1])
                swap(arr[j], arr[j+1]);
}
</code></pre>
<h1><a class="header" href="#selection-sort" id="selection-sort">Selection Sort</a></h1>
<h2><a class="header" href="#소개-3" id="소개-3">1. 소개</a></h2>
<p>오히려 삽입정렬보다 개념을 이해하기는 더 쉬울지도 모르겠다. 1번 원소부터 <code>n</code>개의 원소를 다 둘러보면서 최솟값을 찾은 뒤, 그 값을 원래 1번원소와 바꾸고, 2번 원소부터 <code>n</code>번원소까지 이를 반복하는 것이다. 긴말없이 코드로 보여주도록 하겠다.</p>
<h2><a class="header" href="#코드-1" id="코드-1">2. 코드</a></h2>
<pre><code class="language-c++">void sortarr()
{
    int minnum;
    for(int i=1; i&lt;n; i++){
        minnum=i;
        for(int j=i+1; j&lt;=n; j++)
            if(arr[j]&lt;arr[minnum])
                minnum=j;
        swap(arr[i], arr[minnum]);
    }
}
</code></pre>
<h1><a class="header" href="#insertion-sort" id="insertion-sort">Insertion Sort</a></h1>
<h2><a class="header" href="#소개-4" id="소개-4">1. 소개</a></h2>
<p>\(O(n^2)\)중에서는 개념적으로는 선택정렬까지는 아니지만 버블정렬보다는 쉽지만, 사실 잘 쓰지 않는 정렬 기법이다. \(1\)번부터 \(n\)번의 단계가 있는데, <code>i</code>번째 단계에서는 1번부터 <code>i-1</code>번째원소까지 모두 정렬되어 있는 상황에서 1번부터 <code>i</code>번까지 정렬한다. \(1\)번부터 <code>i-1</code>번까지 정렬되어 있으니, 그냥 뒤에서부터 훑어보면서 이 숫자가 들어갈 곳을 찾으면 된다.</p>
<h2><a class="header" href="#코드-2" id="코드-2">2. 코드</a></h2>
<pre><code class="language-c++">void sortarr()
{
    for(int i=1; i&lt;=n; i++){
        int key=arr[i];
        for(int j=i-1; j&gt;=1; j--){
            if(key&gt;arr[j]){
                arr[j+1]=key;
                break;
            }
            swap(arr[j], arr[j+1]);
        }
    }
}
</code></pre>
<h1><a class="header" href="#merge-sort" id="merge-sort">Merge Sort</a></h1>
<h2><a class="header" href="#소개-5" id="소개-5">1. 소개</a></h2>
<p>병합정렬은 분할정복, 혹은 <a href="algorithm/sort/../divideandconquer/divideandconquer.html">Divide &amp; Conquer</a>를 사용한 알고리즘으로, 폰 노이만이 개발했다고 한다. 병합정렬의 아이디어는 어떤 배열을 두 조각으로 자르는 거에서 시작한다. 만약 두 조각으로 자른 것들이 이미 정렬되어 있다고 하면, 두 조각을 합쳐서 원래 배열을 정렬시키는 데에는 \(O(n)\)의 시간복잡도밖에 걸리지 않는다. 어떻게 하느냐면, “3, 6, 8, 9”와 “1, 4, 7, 10”을 합칠 때(병합할 때) 두 배열에 대한 피벗을 각각 잡아 피벗들끼리 비교하여 더 작은 것부터 원래 배열에 담는 것이다. 즉 이 경우 3과 1, 3과 4, 6과 4, 6과 7, 8과 7, 8과 10, 9와 10을 순서대로 비교하여 새 배열에는 “1, 3, 4, 6, 7, 8, 9, 10”이 들어가게 된다. 그렇다면, 이를 재귀적으로 계속 절반씩 나눠가면서 각 배열의 절반씩을 정렬하면 될 것이다. 그런데, <code>n</code>을 계속 절반으로 쪼개나가는 것이니 재귀탐색은 깊어봤자 \(\log n\)번씩 밖에 실행되지 않을 것이다! 따라서 전체 알고리즘은 \(O(n\log n)\)안에 실행될 것이다. <code>main</code>함수의 <code>arrsort()</code>를 <code>mergesort(1, n)</code>으로 바꾸고 구현한 병합정렬의 코드이다.</p>
<h2><a class="header" href="#코드-3" id="코드-3">2. 코드</a></h2>
<pre><code class="language-c++">void mergesort(int st, int fin)
{
    if(st&gt;=fin)return;
    int mid=(st+fin)/2;
    mergesort(st, mid);
    mergesort(mid+1, fin);
    int pv1=st, pv2=mid+1, merged[100010], re=st;
    while(pv1&lt;=mid||pv2&lt;=fin){
        if(pv1&gt;mid)merged[re++]=arr[pv2++];
        else if(pv2&gt;fin)merged[re++]=arr[pv1++];
        else merged[re++]=arr[pv1]&lt;=arr[pv2]?arr[pv1++]:arr[pv2++];
    }
    for(int i=st; i&lt;=fin; i++){
        arr[i]=merged[i];
    }
}
</code></pre>
<h1><a class="header" href="#heap-sort" id="heap-sort">Heap Sort</a></h1>
<h2><a class="header" href="#소개-6" id="소개-6">1. 소개</a></h2>
<p>우선 힙이라는 자료구조를 안다는 가정하에 설명을 시작하도록 하겠다. 우리는 최소 힙을 이용해 선택정렬의 방법을 최적화할 것이다. 선택정렬에서 어떤 구간의 최솟값을 찾는데 그것을 찾기 위해 <code>n</code>개의 칸을 탐색하던지, 힙을 이용하는지의 차이이다. 힙에서는 원소를 추가하는데 \(\log n\), 삭제하는데 \(\log n\)의 시간복잡도가 필요한 반면, 힙의 최소 혹은 최댓값은 상수시간 안에 구해낼 수 있어 이를 이용해 구현한 힙정렬은 \(O(n\log n)\)의 시간복잡도를 가진다. <code>main</code>함수의 <code>sortarr()</code>을 <code>heapsort()</code>로 바꾼 뒤 작성한 코드이다.</p>
<h2><a class="header" href="#코드-4" id="코드-4">2. 코드</a></h2>
<h3><a class="header" href="#heap-sort-without-priority_queue" id="heap-sort-without-priority_queue">2.1. Heap Sort without priority_queue</a></h3>
<pre><code class="language-c++">void in_heap(int num)
{
    heap[++siz]=num;
    int temp=siz;
    while(temp&gt;1){
        if(heap[temp/2]&gt;heap[temp])swap(heap[temp/2], heap[temp]);
        else break;
        temp/=2;
    }
}
void poptop_heap()
{
    swap(heap[1], heap[siz]);
    heap[siz]=987654321;
    siz--;
    int temp=1;
    while(temp&lt;=siz/2){
        if(heap[temp]&lt;=heap[temp*2]&amp;&amp;heap[temp]&lt;=heap[temp*2+1])break;
        if(heap[temp*2]&lt;=heap[temp*2+1]){
            swap(heap[temp], heap[temp*2]);
            temp*=2;
        }
        else{
            swap(heap[temp], heap[temp*2+1]);
            temp*=2;
            temp++;
        }
    }
}
void heapsort()
{
    for(int i=1; i&lt;=n; i++)
        in_heap(arr[i]);
    for(int i=1; i&lt;=n; i++){
        arr[i]=heap[1];
        poptop_heap();
    }
}
</code></pre>
<h3><a class="header" href="#heap-sort-using-priority_queue" id="heap-sort-using-priority_queue">2.2. Heap Sort using priority_queue</a></h3>
<p>힙이란 자료구조는 이미 우선순위 큐의 형태로 구현되어 있으므로 이를 이용하면 코드가 훨씬 간결해진다. 다만 우선순위 큐는 최대 힙으로 원래 수에 -1을 곱해준 값으로 우선순위 큐 안에 넣어주게 되면 최소 힙처럼 사용할 수 있다.</p>
<pre><code class="language-c++">void heapsort()
{
    priority_queue&lt;int&gt; pq;
    for(int i=1; i&lt;=n; i++)
        pq.push(-arr[i]);
    for(int i=1; i&lt;=n; i++){
        arr[i]=-pq.top();
        pq.pop();
    }
}
</code></pre>
<h1><a class="header" href="#quick-sort" id="quick-sort">Quick Sort</a></h1>
<h2><a class="header" href="#소개-7" id="소개-7">1. 소개</a></h2>
<p>퀵정렬은 다른 알고리즘과는 다르게 시간복잡도가 딱히 정해져 있지 않다. 그 이유는 시간복잡도가 <code>n</code>이 아닌 입력된 배열에 의존하기 때문이다. 퀵정렬은 분할정복을 기본으로 하는데, 어느 하나의 랜덤한 값을 잡아 그보다 작은 값들은 앞으로, 큰 값을 뒤로 몰아놓은 뒤 두 부분을 각각 재귀적으로 정렬해주는 것이다. 시간복잡도는 이때 랜덤하게 잡은 값에 의존하는데, 모든 과정에서 이 랜덤값이 중앙값이면, 시간복잡도는 \(O(nlogn)\)이 되고, 모든 과정에서 랜덤값이 최소이거나 최대이면 시간복잡도가 \(O(n^2)\)이다. 그런데 사실 이럴 일은 매우 드물기 때문에, 안심하고 써도 문제는 없다. <code>main</code>함수의 <code>arrsort()</code>를 <code>quicksort(1, n)</code>으로 바꾸자. 우리는 이 랜덤한 값을 그냥 정렬하는 수들 중 마지막 수로 하자. 실전에서는 이 랜덤한 값을 난수로 처리하거나, 정렬하는 수들중의 중앙값을 이용한다.</p>
<h2><a class="header" href="#코드-5" id="코드-5">2. 코드</a></h2>
<pre><code class="language-c++">void quicksort(int st, int fin)
{
    if(st&gt;=fin)return;
    int temp[100010], fr=st, re=fin-1;
    for(int i=st; i&lt;fin; i++){
        if(arr[i]&lt;=arr[fin])temp[fr++]=arr[i];
        else temp[re--]=arr[i];
    }
    for(int i=st; i&lt;fin; i++)
        arr[i]=temp[i];
    swap(arr[fr], arr[fin]);
    quicksort(st, re);
    quicksort(fr, fin);
}
</code></pre>
<h1><a class="header" href="#counting-sort" id="counting-sort">Counting Sort</a></h1>
<h2><a class="header" href="#소개-8" id="소개-8">1. 소개</a></h2>
<p>정렬하는 수들의 크기가 그리 크지 않고, 모두 0이상일 때 쓰는 정렬인데, 다른 정렬들과 달리 메모리가 굉장히 많이 필요하다. 그러나 수들이 전부 많이 작으면 이보다 빠른 정렬은 없을 것이다. 시간복잡도가 무려 \(O(n+max(arr[i]))\)로, 배열값만 적당하다면 선형시간 안에 정렬을 할수 있기 때문이다. 정렬의 이름답게 각 원소의 개수를 배열에 저장해 둔 뒤 그 자료를 이용해 정렬을 하는 것이다. 다만 최댓값이 9백만 정도가 넘어가면 일반적인 문제에서 메모리 초과가 나게 되는 치명적인 단점이 있다.</p>
<h2><a class="header" href="#코드-6" id="코드-6">2. 코드</a></h2>
<pre><code class="language-c++">void sortarr()
{
    int cnt[100010];
    fill(cnt, cnt+100005, 0);
    for(int i=1; i&lt;=n; i++)cnt[arr[i]]++;
    int num=0, pv=0;
    while(num&lt;n){
        if(!cnt[pv])pv++;
        else{
            arr[++num]=pv;
            cnt[pv]--;
        }
    }
}
</code></pre>
<h1><a class="header" href="#radix-sort" id="radix-sort">Radix Sort</a></h1>
<h2><a class="header" href="#소개-9" id="소개-9">1. 소개</a></h2>
<p>카운팅 정렬의 약점을 완벽하게 보완해주는 정렬 방법이다. 시간복잡도의 <code>d</code>는 각 원소의 자릿수중 최댓값인데, 각 자리수별로 카운팅 정렬을 실행하여 정렬하여 큰 수에 대해서도 정렬을 시행할 수 있다. 물론 가장 큰 자릿수부터 정렬을 시행해 주어야 할 것이다. 래딕스 정렬은 Big Integer라 불리는 <code>unsigned long long int</code> 범위를 훨씬 벗어나는, \(10^{100}\)과 같은 수들을 정렬할 때 유용하게 쓰일 수 있다. 코드는 카운팅 정렬의 것을 약간만 수정하면 되므로 생략하도록 하겠다.</p>
<h1><a class="header" href="#intro-sort" id="intro-sort">Intro Sort</a></h1>
<h2><a class="header" href="#소개-10" id="소개-10">1. 소개</a></h2>
<p>퀵정렬과 힙정렬을 합한 정렬이다. 기본적으로 퀵정렬을 하지만, 어느정도 재귀가 깊어지면 힙정렬을 이용해 퀵정렬에서 나올 수 있는 최악의 시간복잡도를 피해준다. </p>
<h2><a class="header" href="#stl-sort" id="stl-sort">2. STL sort</a></h2>
<p>하지만 이 인트로 정렬은 구현이 지금까지 나온 모든 정렬보다 쉽다! 왜냐하면, C++에서 이 인트로 정렬을 지원해주기 때문에 딱 한줄이면 정렬이 마무리 된다! 실전에서 가장 유용하게 쓰이는 함수라 봐도 무방하고, 그만큼 빠른 정렬이기에 이 단원을 읽으면서 이거 하나만은 꼭 알고 가자. <code>&lt;algorithm&gt;</code> 헤더파일에 존재하는 <code>sort</code>함수는 <code>sort(시작포인터, 끝포인터, 비교함수의 포인터)</code>의 꼴로 이루어져있는데, 3번째 항을 빈칸으로 남겨둔다면 오름차순 정렬을 시행한다. </p>
<h3><a class="header" href="#비교-함수" id="비교-함수">2.1. 비교 함수</a></h3>
<p><code>sort</code>함수의 가장 큰 장점은 <code>int</code>뿐만 아니라 내가 임의로 만든 구조체라던지 <code>pair</code>등의 대소비교가 가능한 모든 자료구조에 대해서 적용이 가능하다는 것이다! 비교함수의 작성법에 대해 아래 코드를 보면서 설명하도록 하겠다.</p>
<pre><code class="language-c++">#include &lt;bits/stdc++.h&gt;
using namespace std;
struct data
{
    int a;
    char c;
}arr[100010];
bool comp(data x, data y)
{
    if(x.a!=y.a)return x.a&lt;y.a;
    return x.c&lt;y.c;
}
int main()
{
    int n;
    scanf(&quot;%d&quot;, &amp;n);
    for(int i=1; i&lt;=n; i++)
        scanf(&quot;%d %c&quot;, &amp;arr[i].a, &amp;arr[i].c);
    sort(arr+1, arr+n+1, comp);
    for(int i=1; i&lt;=n; i++)
        printf(&quot;%d %c\n&quot;, arr[i].a, arr[i].c);
}
</code></pre>
<p>위와 같이 코드를 작성하면, 각 구조체 <code>a</code>값이 작은것, <code>c</code>값이 작은 것의 우선순위로 구조체들이 정렬된다. 즉, <code>sort</code>함수에 내장된 코드들이 <code>comp</code> 함수를 호출할때 <code>x</code>가 앞의 원소, <code>y</code>가 뒤의 원소일때 <code>comp(x, y)</code>가 리턴하는 값이 <code>true</code> 이면 바꾸지 않고 <code>false</code>일때 두 자리가 바뀌게 된다. 다른건 몰라도 이 <code>sort</code>함수의 사용법만큼은 꼭 익혀두기 바란다.</p>
<h1><a class="header" href="#graph-traversal" id="graph-traversal">Graph Traversal</a></h1>
<h2><a class="header" href="#소개-11" id="소개-11">1. 소개</a></h2>
<p>Graph Traversal(그래프 순회)는 정보과학 문제에서 자주 다루는 그래프를 탐색하는 알고리즘으로, 그래프를 다루는 문제를 풀기 위해 기본적으로 알아야 하는 알고리즘이다.</p>
<h2><a class="header" href="#종류-3" id="종류-3">2. 종류</a></h2>
<ul>
<li><a href="algorithm/graphtraversal/./dfs/dfs.html">DFS</a></li>
<li><a href="algorithm/graphtraversal/./bfs/bfs.html">BFS</a></li>
</ul>
<h1><a class="header" href="#dfs" id="dfs">DFS</a></h1>
<h2><a class="header" href="#소개-12" id="소개-12">1. 소개</a></h2>
<h2><a class="header" href="#코드-7" id="코드-7">2. 코드</a></h2>
<h1><a class="header" href="#bfs" id="bfs">BFS</a></h1>
<h2><a class="header" href="#소개-13" id="소개-13">1. 소개</a></h2>
<h2><a class="header" href="#코드-8" id="코드-8">2. 코드</a></h2>
<h1><a class="header" href="#divide--conquer" id="divide--conquer">Divide &amp; Conquer</a></h1>
<h2><a class="header" href="#소개-14" id="소개-14">1. 소개</a></h2>
<p>Divide &amp; Conquer(D&amp;C) 혹은 분할 정복이라 불리는 문제 해결 기법은 최적해를 구할 때 유용하게 사용될 수 있는 기법 중 하나로, 주어진 문제를 두개 이상의 부분 문제들로 분할하고 각각을 해결한 후 이를 다시 합쳐 주어진 문제를 해결하는 방식입니다. 다시 말해, 문제를 여러개의 해결 가능한 부분 문제들로 나누고 각각을 해결한 후 이 결과를 적절히 융합하여 원래 문제의 답을 구하는 방식을 반복하여 문제를 해결하는 방법입니다. 이 방식을 사용하는 이유는 각각을 부분 문제로 분할하고 이를 각각 해결하는 방식이 다른 방식들에 비해 효율적으로 작동하는 경우가 많기 때문입니다. </p>
<h2><a class="header" href="#방법" id="방법">2. 방법</a></h2>
<p>일반적으로 분할 정복 알고리즘의 과정을 정리하자면 다음과 같습니다.</p>
<ol>
<li>문제가 분할이 가능하다면 2개 이상의 부분 문제들로 분할 (Divide)</li>
<li>나뉜 문제가 추가적으로 분할이 가능할 경우 다시 분할, 그렇지 않을 경우 문제를 해결 (Conquer)</li>
<li>아래 단계에서 Conquer 과정을 통해 답을 구한 부분 문제들을 다시 합하여 원래 문제의 답을 구함</li>
</ol>
<h2><a class="header" href="#예시" id="예시">3. 예시</a></h2>
<p>분할 정복 알고리즘은 그 개념이 단순하지만 알고리즘의 효율성을 높이기 위한 방법으로 다양하게 사용되기 때문에 여러 예시들을 통해 분할 정복에 대해 설명하고자 합니다.</p>
<h3><a class="header" href="#a-hrefalgorithmdivideandconquersortmergesortmerge-sorta" id="a-hrefalgorithmdivideandconquersortmergesortmerge-sorta">3.1. <a href="algorithm/divideandconquer/../sort/mergesort">Merge Sort</a></a></h3>
<h3><a class="header" href="#히스토그램에서-가장-큰-직사각형" id="히스토그램에서-가장-큰-직사각형">3.2. 히스토그램에서 가장 큰 직사각형</a></h3>
<p>이 <a href="https://www.acmicpc.net/problem/6549">문제</a>는 주어진 히스토그램에서 얻을 구 있는 가장 큰 직사각형의 넓이를 구하는 문제 입니다. </p>
<p>이 문제를 해결하기 위한 다양한 방법이 있지만, 분할 정복을 사용한 풀이에 대해 설명하려고 합니다. 주어진 히스토그램을 가운데에 위치한 직사각형들 사이를 기준으로 두 개의 부분으로 분할하면 히스토그램의 가장 큰 직사각형은 다음과 같이 세 유형 중 하나에 속하게 됩니다.</p>
<pre><code>1) 분할 선 기준으로 왼쪽 히스토그램의 막대들만 사용하여 만들어진 직사각형
2) 분할 선 기준으로 오른쪽 히스토그램의 막대들을 사용하여 만들어진 직사각형
3) 분할 선을 지나는 직사각형
</code></pre>
<p>1번과 2번의 경우는 재귀함수를 통해 구해 주면 되기 때문에 3번 경우만 고려해 주면 문제를 해결할 수 있게 됩니다. 그리고 이 과정은 그리디 알고리즘을 통해 해결하게 됩니다. 가운데 지점을 기준으로 양 쪽으로 막대를 하나씩 추가하면서 직사각형들을 만들면서 각 직사각형의 크기를 구해주게 되며, 막대를 추가할 때는 왼쪽과 오른쪽의 두 막대 중에서 더 높이가 높은 쪽의 막대를 추가하는 것 만으로도 가장 높이가 높은 직사각형을 구할 수 있게 됩니다.</p>
<p>이 문제의 시간복잡도를 분석하면 각 단계에서 \(O(n)\)의 시간이 걸리게 되고 각 단계 마다 전체 히스토그램의 너비가 절반으로 감소하므로 \(\log n\)의 단계를 거치게 됩니다. 따라서 총 걸리는 시간은 \(O(n \log n)\)이 됩니다.</p>
<h3><a class="header" href="#가장-가까운-두-점-구하기" id="가장-가까운-두-점-구하기">3.3. 가장 가까운 두 점 구하기</a></h3>
<p>이 <a href="https://www.acmicpc.net/problem/2261">문제</a>는 좌표평면 상에 주어진 $n$개의 점들 사이에서 가장 가까운 두 점 사이의 거리를 구해야 하는 문제 입니다. </p>
<p>일반적으로 이 문제는 모든 점 쌍들 간의 거리를 계산하는 방식으로 \( O(n^2) \)의 시간 복잡도로 문제를 해결할 수 있습니다. 그러나 분할 정복을 이용하면 \(O(n \log n)\)의 시간복잡도로 이 문제를 해결 할 수 있게 됩니다.</p>
<p>이 문제에서 분할 정복을 이용하기 위해서 <code>n</code>개의 정점들을 <code>x</code> 좌표를 기준으로 정렬 해 줍니다. 이후 <code>x</code>좌표를 기준으로 점을 두 개의 그룹으로 분할 한 후, 각각의 그룹에 대해 가장 가까운 두 점 사이의 거리를 구하고 최솟값 <code>d</code>를 구합니다. 이때 각 그룹에 있는 점 사이의 거리를 고려하지 않았으므로 이를 고려해 주어야 하는데, 두 그룹을 나누는 기준선에서 \(x\)좌표의 차이가 \(d\) 이상인 경우 최소 거리가 될 수 없으므로 제외한다. 그리고 이 점들을 \(y\)좌표를 기준으로 정렬하여, \(y\)좌표의 차이가 \(d\) 이하인 점들 간에 거리를 구해 준다. 이때, 각 점에 대해 \(y\)좌표의 차이가 \(d\) 이하인 점의 개수는 7개를 넘지 않으므로, \(O(n)\)만에 모든 점 쌍 사이의 최소 거리를 구할 수 있게 된다. 이 과정을 반복하여 답을 구할 수 있게 된다. 그리고 이 알고리즘의 시간 복잡도를 계산하면, \(O(n \log n)\)이 됩니다.</p>
<h1><a class="header" href="#binary-search" id="binary-search">Binary Search</a></h1>
<h1><a class="header" href="#parametric-search" id="parametric-search">Parametric Search</a></h1>
<h1><a class="header" href="#dp" id="dp">DP</a></h1>
<h2><a class="header" href="#소개-15" id="소개-15">1. 소개</a></h2>
<h2><a class="header" href="#예시-1" id="예시-1">2. 예시</a></h2>
<ul>
<li><a href="algorithm/dp/./lcs/lcs.html">LCS</a></li>
<li><a href="algorithm/dp/./knapsack/knapsack.html">0-1 Knapsack</a></li>
</ul>
<h1><a class="header" href="#lcs" id="lcs">LCS</a></h1>
<h2><a class="header" href="#소개-16" id="소개-16">1. 소개</a></h2>
<p>최장 공통 부분 수열은 주어진 여러 개의 수열 모두의 부분 수열이 되는 수열들 중에 가장 긴 것입니다. 부분 수열은 그 수열의 일부 항을 원래 순서대로 나열해 얻을 수 있는 수열입니다. 이때 꼭 연속하지 않아도 되며, 연속한 경우는 최장 공통 문자열이라고 부릅니다.</p>
<p>사실 최장 공통 부분 수열은 문자를 다룰 수도 있습니다. '공통 부분 수열'과 '공통 문자열'의 차이는 연속해야 하는지의 여부입니다. 따라서 '공통 부분 수열'이 꼭 숫자로만 이루어지지 않을 수도 있습니다. <em>1243</em> 은 <em>ABDC</em>일 수도 있고, _@^$&amp;_일 수도 있음을 유의하시기 바랍니다.</p>
<p>아래와 같이 짧은 LCS는 매우 간단하므로 눈으로도 쉽게 답을 찾을 수 있습니다.</p>
<img src="algorithm/dp/lcs/./LCS1.JPG" width = 500 >
<p><em>123762</em>와 <em>123587</em>의 LCS를 찾아봅시다.</p>
<p>두 수열 모두 부분 수열로 <em>137</em>, <em>17</em>, <em>237</em> 등을 가지고 있습니다. 이때 LCS는 <em>1237</em>이 되고, 그 길이는 4입니다.</p>
<h2><a class="header" href="#dp-table" id="dp-table">2. DP Table</a></h2>
<p>LCS를 찾기 위한 일반적인 방법은 DP(동적계획법) Table을 만드는 것입니다. </p>
<img src="algorithm/dp/lcs/./LCS2.jpg" width = 500 > 
<p>주어진 수열이 <em>123762</em>와 <em>123587</em>라고 합시다. 이 표의 가로축과 세로축은 각각의 수열을 의미합니다. 이 표에서 <code>i</code>번째 행,<code>j</code>번째 열의 수를 <code>ARR[i][j]</code>라 할 때 <code>ARR[i][j]</code>는 <code>A</code>를 <code>i</code>번째 수, <code>B</code>를 <code>j</code>번째 수 까지 고려했을 때 최장 수열의 길이입니다. 첫 번째 열과 첫 번째 행은 아직 아무 수도 고려하지 못한 상태이기 떄문에, 최장 수열의 길이는 0입니다.
0이 아닌 <code>i</code>, <code>j</code>에 대해 <code>ARR[i][j]</code>를 다음과 같이 정의할 수 있습니다.</p>
<pre><code class="language-c++">if(A[i]==B[j]){
  // A[i]와 B[j]가 같은 경우
  ARR[i][j] = max(max(ARR[i-1][j], ARR[i][j-1]), ARR[i-1][j-1]+1);
}else{
  // A[i]와 B[j]가 다른 경우
  ARR[i][j] = max(ARR[i-1][j], ARR[i][j-1]);
}
</code></pre>
<p>만약 <code>A[i]</code>와 <code>B[j]</code>가 다르다면, 아무것도 추가할 수 없으므로 <code>A[i]</code>를 확인하기 전 단계인 <code>ARR[i-1][j]</code>와 <code>B[j]</code>를 확인하기 전 단계인 <code>ARR[i][j-1]</code> 중 더 큰 값을 저장하는 것입니다.
<code>A[i]</code>와 <code>B[j]</code>가 같다면 위의 두 선택지에 더해 세 번째 선택지가 존재합니다. 두 수가 같으므로 LCS의 마지막 자리에 추가할 수 있고, 이는 두 수를 모두 고려하기 전까지의 LCS에 1을 더한 <code>ARR[i-1][j-1] + 1</code>입니다.
이 과정을 모두 마치고 나면 LCS의 길이는 표의 가장 마지막 위치 <code>ARR[6][6]</code>에 저장되어 있습니다. (<code>A</code>와 <code>B</code>가 모두 6자리이기 때문입니다.) 즉, <code>A</code>와 <code>B</code>의 모든 수를 다 고려했을 때의 LCS를 의미합니다.
만약 LCS의 길이 뿐만이 아닌 LCS 자체를 구하고 싶다면, 위 표에서 빨간색으로 채워진 칸들을 역으로 추적하면 됩니다. 
위 표에서 예시를 들어 보도록 하겟습니다. 선택되었기에 빨간색이 칠해진 칸들을 보면 모두 공통점이 있습니다. 같은 숫자를 가진 칸들 중 가장 왼쪽 위의 칸이라는 것입니다. 이것은 전 칸에서 넘어올 때 길이가 1 늘었다는 뜻이고, 그 칸이 LCS에 포함된다는 뜻입니다. 따라서 LCS를 구하려면, 끝에서 시작해 왼쪽이나 위에 같은 수가 있으면 그곳으로 가고, 왼쪽 칸과 윗칸이 모두 자신보다 작다면 자신을 LCS에 추가한 후 왼쪽 위에 있는 칸으로 가면 됩니다.</p>
<h2><a class="header" href="#code" id="code">3. Code</a></h2>
<p>지금까지 설명한 내용이 그대로 담겨 있는 문제가 있습니다. 따라서 구현 코드와 문제 설명을 같이 하겠습니다.<a href="https://www.acmicpc.net/problem/9252">이 문제</a>는 두 문자열을 입력받은 후, LCS의 길이와 LCS를 출력하는 문제입니다.</p>
<pre><code class="language-c++">#include &lt;bits/stdc++.h&gt;
using namespace std;
char A[1010], B[1010], LCS[1010];
int DP[1010][1010], LEN;
int main() {
    scanf(&quot;%s&quot;, A + 1);
    scanf(&quot;%s&quot;, B + 1);
    
    // strlen()의 이용을 위해
    // A[0]과 B[0]에 임의의 문자를 입력
    A[0] = B[0] = '.';
    
    // lenA와 lenB는 각각 A와 B의 길이
    int lenA = strlen(A) - 1, lenB = strlen(B) - 1;
    
    for(int i = 1; i &lt;= lenA; i++) {
        for(int j = 1; j &lt;= lenB; j++) {
            if(A[i] == B[j])
                // A[i]와 B[j]가 같아서
                // LCS를 늘릴 수 있는 경우
                DP[i][j] = max(DP[i - 1][j - 1] + 1, max(DP[i - 1][j], DP[i][j - 1]));
            else
                // 다른 경우
                DP[i][j] = max(DP[i - 1][j], DP[i][j - 1]);
        }
    }
    
    LEN = DP[lenA][lenB];
    
    //LCS의 길이 출력
    printf(&quot;%d\n&quot;, LEN);
    
    int a = lenA, b = lenB;
    
    while(LEN &gt; 0) {
        if(DP[a][b] == DP[a - 1][b]) {
            // DP[a][b]가 색칠되지 않은 경우
            a--;
        }
        else if(DP[a][b] == DP[a][b - 1]) {
            // DP[a][b]가 색칠되지 않은 경우
            b--;
        }
        else {
            // DP[a][b]가 색칠되었고 LCS에 해당하는 경우
            
            // A[a]와 B[b]중 어떤 것을 써도 상관없다.
            LCS[LEN - 1] = A[a];
            a--;
            b--;
            LEN--;
        }
    }
    
    //LCS 출력
    printf(&quot;%s\n&quot;, LCS);
}
</code></pre>
<h1><a class="header" href="#shortest-path" id="shortest-path">Shortest Path</a></h1>
<h2><a class="header" href="#소개-17" id="소개-17">1. 소개</a></h2>
<p>Shortest Path(최단 거리) 알고리즘은 주어진 가중 그래프에서 두 정점 사이 최단거리를 구하는 문제다. 다양한 최단 거리 알고리즘이 존재하는데, 간선들의 가중치나 최단거리를 구하려는 시작점, 끝점의 개수에 따라 맞는 알고리즘을 잘 선택하여 사용해야 한다.</p>
<h2><a class="header" href="#종류-4" id="종류-4">2. 종류</a></h2>
<ul>
<li>
<p><a href="algorithm/shortestpath/../graphtraversal/bfs/bfs.html">BFS</a></p>
<p>모든 간선의 가중치가 1일때 한 정점에서 모든 정점까지 최단 거리를 \(O(V+E)\)에 구할 수 있다.</p>
</li>
<li>
<p><a href="algorithm/shortestpath/./dijkstra/dijkstra.html">Dijkstra</a></p>
<p>모든 간선의 가중치가 0 이상일 때 한 정점에서 모든 정점까지 최단 거리를 \(O(E\log V)\)에 구할 수 있다.</p>
</li>
<li>
<p><a href="algorithm/shortestpath/./bellmanford/bellmanford.html">Bellman-Ford</a></p>
<p>음수 사이클이 없는 그래프에서, 한 정점에서 모든 정점까지 최단 거리를 \(O(VE)\)에 구할 수 있다.</p>
</li>
<li>
<p><a href="algorithm/shortestpath/./floydwarshall/floydwarshall.html">Floyd-Warshall</a></p>
<p>음수 사이클이 없는 그래프에서, 모든 정점쌍에 대한 최단거리를 \(O(V^3)\)에 구할 수 있다.</p>
</li>
</ul>
<h1><a class="header" href="#dijkstra" id="dijkstra">Dijkstra</a></h1>
<h1><a class="header" href="#bellman-ford" id="bellman-ford">Bellman-Ford</a></h1>
<h1><a class="header" href="#floyd-warshall" id="floyd-warshall">Floyd-Warshall</a></h1>
<h1><a class="header" href="#query-technique" id="query-technique">Query Technique</a></h1>
<h2><a class="header" href="#소개-18" id="소개-18">1. 소개</a></h2>
<p>알고리즘 문제 중에서 주어진 쿼리를 처리하는 코드를 구현하는 문제들이 있다. 쿼리들의 경우 원소를 추가하거나 삭제하는 쿼리, 특정 연산을 하는 쿼리 등 문제에 따라 다양한 종류가 주어진다. 따라서, 쿼리 문제들에 유용하게 사용할 수 있는 기술들을 다양하게 알아놓고, 문제를 풀기 위해서는 주어진 쿼리의 특징에 따라 적절한 기술을 적용해야 한다.</p>
<h2><a class="header" href="#종류-5" id="종류-5">2. 종류</a></h2>
<ul>
<li><a href="algorithm/query/./hld/hld.html">Heavy-Light Decomposition</a></li>
<li><a href="algorithm/query/./sqrt/sqrt.html">Sqrt Decomposition</a></li>
<li><a href="algorithm/query/./mos/mos.html">Mo's Algorithm</a></li>
<li><a href="algorithm/query/./gridcompression/gridcompression.html">Grid Compression</a></li>
<li><a href="algorithm/query/./centroid/centroid.html">Centroid Decomposition</a></li>
</ul>
<h1><a class="header" href="#heavy-light-decomposition" id="heavy-light-decomposition">Heavy-Light Decomposition</a></h1>
<h2><a class="header" href="#소개-19" id="소개-19">1. 소개</a></h2>
<p>HLD는 트리에 대한 연산을 긴 직선에 대한 연산처럼 바꾸어 할 수 있도록 하는 방법입니다.
따라서, 이 글을 이해하기 위해서는, Segment Tree,dfs,lca(sparse table)등에 대한 이해가 필요합니다. </p>
<p>HLD는 Heavy Light Decomposition 의 약자로서, 간선을 무거운 간선과 가벼운 간선으로 나누어 분류해 관리하는 방법입니다. 이를 위해서는 트리가 rooted Tree여야 합니다.(Root를 하나로 정해야 합니다) 그리고 트리의 정점의 무게를 그 정점의 Subtree의 크기로 정의합시다. 그리고 부모와 자식을 잇는 간선 중에 자식이 부모의 무게의 반 이상인 간선을 무거운 간선으로 정의합시다.</p>
<p>그러면 여기서 두 가지 사실을 이끌어낼 수 있습니다. </p>
<ul>
<li>
<p>한 정점에서 자식으로 가는 간선 중 무거운 간선은 단 한개이다.
두 자식이 모두 부모의 무게의 반 이상이 될 수는 없기 때문입니다.</p>
</li>
<li>
<p>root에서 한 정점으로 가는 경로에 가벼운 간선은 \(O(\log N)\)개이다. 
가벼운 간선을 통해서 내려간다면 무게가 반 이상으로 줄어들기 때문에 이 또한 자명합니다.</p>
</li>
</ul>
<p>무거운 간선들이 인접해 있다면 그것을 하나로 이은 것을 무거운 경로라고 합시다.  그 무거운 경로의 맨 위의 가벼운 간선도 경로에 포함시키고, 아래에 무거운 경로가 없는 가벼운 간선은 그것 하나를 무거운 경로로 본다면, 트리의 경로를 여러개의 무거운 경로로 바꾸어 볼 수 있습니다.</p>
<p>이런 무거운 경로가 끊어지는 것은 가벼운 간선을 만날 때만이기 때문에, 아까 언급한 2번 사실에 의해 트리의 어떤 경로는 항상 \(O(\log N)\)개의 무거운 경로들의 일부의 합으로 나타내어질 수 있습니다.</p>
<p>이 사실을 이용해서 무거운 경로들을 Segment Tree를 이용해서 관리해준다면 트리의 경로에 대한 연산을 직선에 대한 연산처럼 할 수 있을 것입니다.((ex)RMQ,구간 합 쿼리)  이것이 바로 HLD입니다.</p>
<h2><a class="header" href="#예시-2" id="예시-2">2. 예시</a></h2>
<p><a href="algorithm/query/hld/acmicpc.net/problem/13510">HLD를 통해 풀 수 있는 쿼리 문제 하나</a>를 소개하고자 합니다. 문제를 요약하면 다음과 같습니다.</p>
<blockquote>
<p><code>N</code>개의 정점으로 이루어진 트리(무방향 사이클이 없는 연결 그래프)가 있다. 정점은 1번부터 <code>N</code>번까지 번호가 매겨져 있고, 간선은 1번부터 <code>N</code>-1번까지 번호가 매겨져 있다.</p>
<p>아래의 두 쿼리를 수행하는 프로그램을 작성하시오.</p>
<p>1 <code>i</code> <code>c</code>: <code>i</code>번 간선의 비용을 <code>c</code>로 바꾼다.</p>
<p>2 <code>u</code> <code>v</code>: <code>u</code>에서 <code>v</code>로 가는 경로에 존재하는 비용 중에서 가장 큰 것을 출력한다.</p>
<p>첫째 줄에 N (2 \(\leq\) N \(\leq\) 100,000)이 주어진다.
둘째 줄부터 N-1개의 줄에는 i번 간선이 연결하는 두 정점 번호 u와 v와 비용 w가 주어진다.
다음 줄에는 쿼리의 개수 M (1 \(\leq\) M \(\leq\) 100,000)이 주어진다.
다음 M개의 줄에는 쿼리가 한 줄에 하나씩 주어진다.
간선의 비용은 항상 1,000,000보다 작거나 같은 자연수이다.</p>
</blockquote>
<p>트리 경로에서의 구간 최대 쿼리, 업데이트 연산을 수행해주면 되는 문제입니다.
HLD 를 사용해 \(O(M\log^2N)\)에 풀 수 있습니다. </p>
<p>밑에는 코드 부분부분에 관한 설명이 있습니다. Segment Tree를 만드는 부분, lca에 관련된 spars table, dfs를 이용한 무게 구하기와 깊이 구하기 등은 이미 알고 있다고 생각하고 설명을 생략했습니다.</p>
<h3><a class="header" href="#hld" id="hld">2.1. HLD</a></h3>
<pre><code class="language-c++">void hld(int root){
    queue&lt;int&gt; q;
    q.push(root);
    while(!q.empty()){
        int now=q.front();
        q.pop();
        for(auto i:children[now]){
            q.push(i);
        }
        if(now==root) continue;
        int prt=parent[0][now];
        if(weight[now]*2&gt;=weight[prt]&amp;&amp;prt!=root){
            int prtheavynum=heavynum[prt];
            heavy_path[prtheavynum].push_back(now);
            heavynum[now]=prtheavynum;
        }
        else{
            heavynum[now]=(int)heavy_path.size();
            heavy_path.push_back(vector&lt;int&gt;(2));
            heavy_path.back()[0]=prt;
            heavy_path.back()[1]=now;
        }
    }
}
</code></pre>
<p><code>root</code>부터 너비 우선 탐색으로 경로를 만들어줍니다. 간선은 번호가 없기에, 간선을 관리하려면 자식의 번호를 이용해서 그 자식과 부모를 잇는 간선을 관리해주는 것이 편리합니다.</p>
<p><code>heavynum</code>은 각 간선이 포함된 무거운 경로의 번호이고, <code>heavy_path</code>는 무거운 경로들의 모음 <code>vector</code>입니다. </p>
<p>만약 자신이 <code>root</code>라면 자신 위에 간선이 없기에 아무것도 하지 않습니다.
만약 부모 무게가 자신의 무게의 2배보다 작고 부모가 <code>root</code>가 아니라면, 무거운 간선이므로 이미 있던 무거운 경로에 추가해줍니다.</p>
<p>부모가 <code>root</code>이거나 가벼운 간선이면 새로운 무거운 경로의 시작이므로 새로운 무거운 경로를 만들어줍니다.</p>
<h3><a class="header" href="#update" id="update">2.2. Update</a></h3>
<pre><code class="language-c++">int findedge(int pathidx,int v){
    int top=heavy_path[pathidx][0];
    return depth[v]-depth[top]-1;
}
void update(int u,int v,int cost){
    if(parent[0][u]==v) swap(u,v);
    int pathidx=findedge(heavynum[v],v);
    segment_trees[heavynum[v]].update(pathidx,cost);
}
</code></pre>
<p><code>update</code>는 간단합니다.</p>
<p><code>findedge</code>는 무거운 경로에서 몇번째 간선인지 찾아줍니다. 맨 위의 정점은 나타내는 간선이 없으므로 -1을 해줍니다.</p>
<p><code>u</code>가 <code>v</code>의 부모로 유지한 뒤, 몇번째 간선인지 Segment Tree에서 찾아서 갱신해주면 끝입니다.</p>
<h3><a class="header" href="#query" id="query">2.3. Query</a></h3>
<pre><code class="language-c++">int query_topdown(int p,int v){
    if(p==v) return -1;
    if(heavynum[p]==heavynum[v]){
        int pathidx=heavynum[p];
        int s=findedge(pathidx, p)+1;
        int e=findedge(pathidx, v);
        return segment_trees[pathidx].query(s, e);
    }
    
    int pathidx=heavynum[v];
    int top=heavy_path[pathidx][0];
    int e=findedge(pathidx, v);
    return max(segment_trees[pathidx].query(0, e),query_topdown(p, top));
}
int query(int u,int v){
    int p=lca(u,v);
    return max(query_topdown(p,v),query_topdown(p,u));
}
</code></pre>
<p><code>query</code>는 조금 복잡합니다.
우선, <code>u</code>,<code>v</code>의 <code>lca</code>를 구한 뒤 두 부분으로 나누어 계산합니다.</p>
<p><code>query_topdown</code>에서는 만약 <code>p</code>,<code>v</code>가 같다면 간선이 없으므로 -1을 리턴하고,
두개가 같은 무거운 경로에 속했다면 Segment Tree에서 계산해줍니다.
만약 아니라면 <code>v</code>가 속한 무거운 경로의 맨 위 정점까지 올라가면서 그 사이의 간선들에 대한 연산을 Segment Tree로 해주고, 그 맨 위 정점과 p에 대한 연산을 <code>query_topdown</code>으로 다시 처리해줍니다.</p>
<p><code>query_topdown</code> 은 최대 \(O(\log N)\) 번 호출되는데, 아까 언급했듯이 만날 수 있는 무거운 경로의 개수가 그렇기 때문입니다.</p>
<h1><a class="header" href="#sqrt-decomposition" id="sqrt-decomposition">Sqrt Decomposition</a></h1>
<h1><a class="header" href="#mos-algorithm" id="mos-algorithm">Mo's Algorithm</a></h1>
<h1><a class="header" href="#grid-compression" id="grid-compression">Grid Compression</a></h1>
<h1><a class="header" href="#centroid-decomposition" id="centroid-decomposition">Centroid Decomposition</a></h1>
<h1><a class="header" href="#dp-optimization" id="dp-optimization">DP Optimization</a></h1>
<h2><a class="header" href="#소개-20" id="소개-20">1. 소개</a></h2>
<p><a href="algorithm/dpopt/../dp/dp.html">Dynamic Programming</a>을 사용해 문제를 푸는 과정에서 특정 형태의 점화식을 갖는 문제들에서는 최적화 기법을 통해 시간복잡도를 줄일 수 있는데, 이를 DP Optimization(동적 계획법 최적화)라고 한다. 문제에서 구해낸 점화식에 따라 그에 맞는 최적화 기법을 사용하여 더 빠른 시간에 동작하는 코드를 짤 수 있어야 한다.</p>
<h2><a class="header" href="#종류-6" id="종류-6">2. 종류</a></h2>
<ul>
<li><a href="algorithm/dpopt/./dnc/dnc.html">Divide and Conquer Optimization</a></li>
<li><a href="algorithm/dpopt/./knuth/knuth.html">Knuth Optimization</a></li>
<li><a href="algorithm/dpopt/./cht/cht.html">Convex Hull Trick</a></li>
</ul>
<h1><a class="header" href="#divide--conquer-optimization" id="divide--conquer-optimization">Divide &amp; Conquer Optimization</a></h1>
<h1><a class="header" href="#knuth-optimization" id="knuth-optimization">Knuth Optimization</a></h1>
<h1><a class="header" href="#convex-hull-trick" id="convex-hull-trick">Convex Hull Trick</a></h1>
<h1><a class="header" href="#network-flow" id="network-flow">Network Flow</a></h1>
<h2><a class="header" href="#소개-21" id="소개-21">1. 소개</a></h2>
<h2><a class="header" href="#응용" id="응용">2. 응용</a></h2>
<ul>
<li><a href="algorithm/networkflow/./bimatching/bimatching.html">Matching on Bipartite</a></li>
<li><a href="algorithm/networkflow/./mcmf/mcmf.html">Minimum Cost Maximum Flow</a></li>
</ul>
<h1><a class="header" href="#matching-on-bipartite" id="matching-on-bipartite">Matching on Bipartite</a></h1>
<h1><a class="header" href="#minimum-cost-maximum-flow" id="minimum-cost-maximum-flow">Minimum Cost Maximum Flow</a></h1>
<h1><a class="header" href="#geometry" id="geometry">Geometry</a></h1>
<h2><a class="header" href="#소개-22" id="소개-22">1. 소개</a></h2>
<h2><a class="header" href="#a-hrefalgorithmgeometryconvexhullconvexhullconvex-hulla" id="a-hrefalgorithmgeometryconvexhullconvexhullconvex-hulla">2. <a href="algorithm/geometry/./convexhull/convexhull">Convex Hull</a></a></h2>
<h2><a class="header" href="#a-hrefalgorithmgeometryrotatingcallipersrotatingcallipershtmlrotating-callipersa" id="a-hrefalgorithmgeometryrotatingcallipersrotatingcallipershtmlrotating-callipersa">3. <a href="algorithm/geometry/./rotatingcallipers/rotatingcallipers.html">Rotating Callipers</a></a></h2>
<h1><a class="header" href="#convex-hull" id="convex-hull">Convex Hull</a></h1>
<h1><a class="header" href="#rotating-callipers" id="rotating-callipers">Rotating Callipers</a></h1>
<h1><a class="header" href="#string" id="string">String</a></h1>
<h2><a class="header" href="#소개-23" id="소개-23">1. 소개</a></h2>
<h2><a class="header" href="#관련-알고리즘" id="관련-알고리즘">2. 관련 알고리즘</a></h2>
<ul>
<li><a href="algorithm/string/./kmp/kmp.html">KMP</a></li>
<li><a href="algorithm/string/./manacher/manacher.html">Manacher Algorithm</a></li>
<li><a href="algorithm/string/./hashing/hashing.html">Hashing</a></li>
<li><a href="algorithm/string/./suffixarray/suffixarray.html">Suffix Array</a></li>
<li><a href="algorithm/string/./ahocorasick/ahocorasick.html">Aho-Corasick</a></li>
</ul>
<h1><a class="header" href="#kmp" id="kmp">KMP</a></h1>
<h1><a class="header" href="#manacher-algorithm" id="manacher-algorithm">Manacher Algorithm</a></h1>
<h1><a class="header" href="#hashing" id="hashing">Hashing</a></h1>
<h2><a class="header" href="#소개-24" id="소개-24">1. 소개</a></h2>
<p>일반적으로 배열에서의 탐색은 전 탐색 시에 \(O(N)\), 정렬하고 이분 탐색 시에 \(O(\log N)\) 으로 처리 가능합니다. 그러나, 어떤 경우에는 이러한 시간복잡도로도 부족하여서, 또는 정렬하고 이분 탐색하는 것이 불가능할 때 해싱이라는 기법을 사용합니다.
해싱이란 데이터의 효율적인 관리를 위하여 임의의 길이의 데이터를 고정된 길이의 데이터로 변환하여 처리하는 과정입니다.
해싱은 크게 두 개의 부분으로 이루어지는데, 그것은 해시 테이블과 해시 함수입니다.</p>
<h2><a class="header" href="#hash-table" id="hash-table">2. Hash Table</a></h2>
<p>일반적인 자료구조를 사용하면 위에서 말했듯이, 하나의 원소를 탐색하는데 최소 \(O(\log N)\)의 시간이 필요하게 됩니다. 이를 해시 테이블을 이용하여 시간을 줄일 수 있습니다. 
해시 테이블은 공간을 담보로 시간을 사는 자료구조입니다. 데이터를 해시 함수에 넣어서 나온 주소에 데이터를 저장하게 되는데, 이때 데이터로 채워지지 않은 공간이 많아야 해시 테이블이 뒤에서 다룰 해시 충돌을 일으키지 않기 때문입니다.</p>
<img src="algorithm/string/hashing/./hashing1.png" width = 400 >
<h2><a class="header" href="#hash-function" id="hash-function">3. Hash Function</a></h2>
<p>해시 함수는 가지고 있는 데이터를 해시 테이블 내의 주소로 변환하는 함수입니다.
이 해시 함수는 해싱 과정 전체에서 매우 중요한 역할을 맡습니다. 해시 함수를 잘 짜야 해시 충돌이 일어나지 않고, 이론적인 성능에 더 가까워지기 때문입니다.
다음은 가장 흔히 알려진 해시 함수들입니다.</p>
<h3><a class="header" href="#나눈셈법" id="나눈셈법">3.1. 나눈셈법</a></h3>
<p>가장 기본적인 해시 함수입니다.
주어진 데이터를 <code>integer</code> 값으로 변환한 뒤, 그 <code>integer</code> 값을 해시 테이블의 전체 크기로 나누는 방식입니다.
$$ Index = data % size $$ </p>
<p>C++ STL의 <code>unordered_map</code>과 <code>unordered_set</code>도 이와 같은 나눗셈법을 사용한다고 합니다.</p>
<pre><code class="language-c++">int HashFunction(int Key, int TableSize){
	return Key%TableSize;
}
</code></pre>
<h3><a class="header" href="#곱셈법" id="곱셈법">3.2. 곱셈법</a></h3>
<p><code>Key</code>가 실수이고 \(0 \leq A \le 1\)인 <code>A</code>에 대하여, 곱셈법은 다음과 같이 정의합니다.</p>
<p>$$ Hash(Key) = {KeyA} \times TableSize $$
단, <code>{x}</code>는 <code>x</code>의 소수 부분의 값이다. <code>TableSize</code>는 중요하지는 않지만, 이진법 연산을 하는 컴퓨터의 특성상 2의 거듭제곱을 사용하는 것이 살짝 더 빠릅니다.</p>
<pre><code class="language-c++">int HashFunction(double Key, int TableSize){
	double d=(double)((int)Key);
	return (int)((Key-d)*TableSize);
}
</code></pre>
<h3><a class="header" href="#문자열" id="문자열">3.3. 문자열</a></h3>
<p>문자열을 해싱하기 위해 정수로 바꾸는 방법은 여러 가지가 있지만, 가장 흔히 쓰이는 방법은 다음과 같습니다.</p>
<pre><code class="language-c++">long long HashFunction(char * Key, int KeyLen, int TableSize){
	long long val=0 ;
	int Prime[]={/*해싱에 사용되는 소수들의 배열*/}
	for (int i=0 ; i&lt;KeyLen; i++)
    val+=Prime[Key[i]];	//val 값을 TableSize에 맞게 해싱해준다.
	return val;
}
</code></pre>
<h3><a class="header" href="#universal-method" id="universal-method">3.4. Universal Method</a></h3>
<p>유니버설 해싱은 다음의 특성을 가지는 해시 함수를 선택하기 위한 확률적 알고리즘입니다. 어떤 두 개의 서로 다른 데이터 <code>x, y</code>에 대하여 <code>x</code> 와 <code>y</code> 간에 해시 충돌이 발생할 확률, 다시 말해 <code>F(x)=F(y)</code>일 확률이 <code>F</code>가 랜덤 함수일 확률과 같다. 따라서, <code>F</code>가 정의역의 크기가 <code>r</code>인 함숫값을 가질 때, 특정 해시 충돌이 발생할 확률은 최대 \(r^{-1}\)과 같다.
이 Universal Method는 특정 함수가 아닌, 위와 같은 조건을 만족하는 함수를 통틀어서 지칭하는 기법입니다. 따라서 다양한 함수들이 Universal Method의 조건을 만족할 수 있습니다.</p>
<h2><a class="header" href="#hash-collision" id="hash-collision">4. Hash Collision</a></h2>
<p>해시 충돌은 해시 함수가 중요한 이유입니다. 해시 충돌이란 서로 다른 데이터가 동일한 해시값을 가지게 되어 해시 테이블에서 인덱스가 겹치게 되는 경우입니다. 해시 충돌이 일어나는 경우, 해시 충돌을 처리하는 과정에서 시간이 소모되므로 해시 테이블이 이론적인 성능을 내지 못하게 됩니다. 따라서 해시 충돌이 일어날 때의 해시 테이블에서의 처리도 중요하지만, 해시 충돌 자체가 적게 일어나도록 해시 함수 자체를 해시 충돌이 일어날 확률이 적게 만들어야 합니다.
해시 충돌을 해시 테이블에서 처리하는 방법은 여러 가지가 있습니다. 대표적으로는 해시 충돌이 일어났을 때 해당 인덱스에 Linked List를 만들어서 처리하는 방법이나, 다른 인덱스로 넘어가서 데이터를 저장하는 방법 등이 있습니다. 전자는 해당 인덱스의 원소 개수만큼의 시간복잡도를 소모하지만 다른 인덱스에 간섭을 안하고, 후자는 다음으로 나오는 빈 인덱스까지의 거리 만큼의 시간복잡도만 소모하지만 다른 인덱스를 차지하게 되어 해당 인덱스를 해시값으로 가지는 데이터의 탐색 시간까지 늘려버릴 수 있습니다.
이처럼, 해시 충돌이 일어나게 되면 극단적이면 전탐색과 비슷한 시간복잡도가 나올 수 있으므로 해시 함수 자체에서 해시 충돌을 방지하는 코드를 짜는 것이 좋습니다.</p>
<h2><a class="header" href="#예제" id="예제">5. 예제</a></h2>
<p><a href="https://www.acmicpc.net/problem/10840">구간 성분(KOI 2015 고등부 2번)</a></p>
<p>이 문제는 \(S_A\)와 \(S_B\)내의 구성 성분이 같은 가장 긴 부분 문자열의 길이를 구하는 문제입니다.</p>
<p>일단 단순하게 생각한다면 길이가 같은 \(S_A\)와 \(S_B\)의 부분 문자열을 서로 모두 비교해 보는 방식으로 \(O(N^4)\)으로 구할 수 있습니다. Time Limit이 1000ms이므로 이를 통해 부분문제 1을 통과할 수 있습니다.</p>
<p>Set이나 Map 등의 \(O(\log N)\)만에 탐색을 해주는 자료구조에 \(S_A\)의 구간성분을 저장한 26칸짜리 배열을 넣어주어서 \(S_B\)의 구간성분과 비교하여 준다면 시간복잡도 자체는 \(O(N^2\log N)\)이 되지만, 상수로 26이 붙게 되므로 부분문제 2만을 추가적으로 통과하게 됩니다.</p>
<p>해싱을 적용하여 \(O(\log N)\)만에 탐색을 해주는 자료구조에 의 각 구간의 구간성분을 해싱하여 넣어준다면, 의 각 구간의 구간성분이 Table에 존재하는지 \(O(\log N)\)만에 확인이 가능합니다. 또한, 구간성분의 길이가 바뀔 때마다 초기화를 해준다면 최대 <code>long long</code> 크기의 <code>integer</code> 1500개만을 자료구조에 저장하게 되므로 ML도 넉넉하게 만족하게 됩니다. 따라서 전체 시간복잡도는 \(O(N^2\log N)\)이 되어, 간단하게 부분문제 3, 4를 통과하게 됩니다.</p>
<h2><a class="header" href="#여담-2" id="여담-2">6. 여담</a></h2>
<p>해싱은 Problem Solving 이외에도 해시값과 원본 데이터 사이의 관계가 없다는 점을 이용하여 보안에 널리 이용됩니다. 특히 최근 비트코인 등으로 인해 화제가 되었던 암호화폐에 적용되는 위변조 방지 기술인 ‘블록체인’에 사용됩니다.
사실 해싱은 PS보다는 실제 개발 등에서 많이 쓰이는 기법이지만, 해싱 이외의 풀이로는 TLE나 MLE가 나는 문제에서 시간, 공간 복잡도를 줄이기에 좋은 방법이 될 수 있습니다.</p>
<h1><a class="header" href="#suffix-array" id="suffix-array">Suffix Array</a></h1>
<h1><a class="header" href="#aho-corasick" id="aho-corasick">Aho-Corasick</a></h1>
<h1><a class="header" href="#basic-data-structure" id="basic-data-structure">Basic Data Structure</a></h1>
<h2><a class="header" href="#소개-25" id="소개-25">1. 소개</a></h2>
<p>기본 자료구조은 입력받은 데이터를 저장하고, 사용할 수 있도록 하는 기초적인 자료 저장 방식으로 구성되어 있다. 각 자료구조의 특성을 정확히 이해하여, 문제를 푸는 과정에서 필요한 적절한 자료구조를 선택하여 사용할 수 있어야 한다.</p>
<h2><a class="header" href="#종류-7" id="종류-7">2. 종류</a></h2>
<ul>
<li><a href="datastructure/basic/./stack/stack.html">Stack</a></li>
<li><a href="datastructure/basic/./queue/queue.html">Queue</a></li>
<li><a href="datastructure/basic/./vector/vector.html">Vector</a></li>
<li><a href="datastructure/basic/./deque/deque.html">Deque</a></li>
<li><a href="datastructure/basic/./linkedlist/linkedlist.html">Linked List</a></li>
<li><a href="datastructure/basic/./structure/structure.html">Structure</a></li>
</ul>
<h1><a class="header" href="#stack" id="stack">Stack</a></h1>
<h1><a class="header" href="#queue" id="queue">Queue</a></h1>
<h1><a class="header" href="#vector" id="vector">Vector</a></h1>
<h1><a class="header" href="#deque" id="deque">Deque</a></h1>
<h1><a class="header" href="#linked-list" id="linked-list">Linked List</a></h1>
<h1><a class="header" href="#structure" id="structure">Structure</a></h1>
<h1><a class="header" href="#intermediate-data-structure" id="intermediate-data-structure">Intermediate Data Structure</a></h1>
<h2><a class="header" href="#소개-26" id="소개-26">1. 소개</a></h2>
<p>중급 자료구조는 난이도 있는 문제를 푸는 과정에서 자주 사용되는 자료구조들로, 대부분은 라이브러리에 작성되어있는 자료구조를 사용하지만 그 내부 원리와 사용 방법을 알아야 문제 없이 사용할 수 있습니다.</p>
<h2><a class="header" href="#종류-8" id="종류-8">2. 종류</a></h2>
<ul>
<li><a href="datastructure/intermediate/./map/map.html">Map</a></li>
<li><a href="datastructure/intermediate/./set/set.html">Set</a></li>
<li><a href="datastructure/intermediate/./priorityqueue/priorityqueue.html">Priority Queue</a></li>
<li><a href="datastructure/intermediate/./bitmask/bitmask.html">Bitmask</a></li>
<li><a href="datastructure/intermediate/./heap/heap.html">Heap</a></li>
<li><a href="datastructure/intermediate/./redblacktree/redblacktree.html">Red Black Tree</a></li>
</ul>
<h1><a class="header" href="#map" id="map">Map</a></h1>
<h1><a class="header" href="#set" id="set">Set</a></h1>
<h1><a class="header" href="#priority-queue" id="priority-queue">Priority Queue</a></h1>
<h1><a class="header" href="#bitmask" id="bitmask">Bitmask</a></h1>
<h2><a class="header" href="#소개-27" id="소개-27">1. 소개</a></h2>
<p>그럼 이제 본격적으로 비트마스킹이 뭔지 설명할 차례입니다. 비트마스킹에는 <a href="datastructure/intermediate/bitmask/../bitoperator/bitoperator.html">비트 연산자</a>가 모든 연산을 차지합니다. 먼저 비트마스크(Bitmask)의 정의부터 살펴봅시다. 비트마스크란, 비트를 변경하여 정보를 저장하는 정수를 뜻합니다. 비트마스킹 기법은 이 비트마스크를 사용하여 메모리 및 연산속도를 대폭 줄일 수 있습니다.</p>
<h2><a class="header" href="#장점" id="장점">2. 장점</a></h2>
<p>비트마스크는 다음과 같은 주요 장점이 있습니다.</p>
<ul>
<li>
<p><strong>메모리 사용량의 큰 단축</strong></p>
<p>비트마스크는 하나의 bool연산자를 하나의 비트로 대체할 수 있습니다. 실제 하나의 int형 정수는 32비트이므로, bool 연산자 32개(\(2 \times 32 = 64\)(byte))를 int형 정수 1개(4(byte))로 줄일 수 있습니다. 그렇게 함으로써, 긴 bool 배열을 짧은 정수배열로 바꾸어 메모리를 16배 가량 줄일 수 있게 해줍니다.</p>
</li>
<li>
<p><strong>실행시간의 단축</strong></p>
<p>실제로 연산 <code>4 * 2</code>와 <code>4 &lt;&lt; 1</code>은 차이가 눈에 띄게 있지 않습니다. 그러나 이 연산이 몇천번정도 반복된다면 이야기가 달라집니다. 일반적인 사칙연산은 비트연산을 여러번 진행한 다음 그 결과값을 반환하지만 비트연산은 딱 한번의 연산만 필요하기 때문에 실행시간을 많게는 반 가량 단축시킬 수 있습니다.</p>
</li>
<li>
<p><strong>코드 길이의 단축</strong></p>
<p>비트마스크를 쓸 경우 복잡한 코드가 한주로 짧게 줄어들 수 있습니다. 비트마스킹만 잘 안다면, 코드의 가독성이 향상될 것입니다.</p>
</li>
</ul>
<h2><a class="header" href="#코드-9" id="코드-9">3. 코드</a></h2>
<p>비트마스킹으로 배열에 있는 많은 기능들을 구현해 봅시다. 대부분의 구현들이 간단한 비트연산 한번으로 가능합니다. 다음 코드를 봅시다.</p>
<pre><code class="language-c++">#include &lt;bits/stdc++.h&gt; 

int Bitmask;

int main(){
    Bitmask = 10; //이진수로 1010
    int n, tmp = Bitmask;
    scanf(&quot;%d&quot;, &amp;n);
    if(Bitmask &amp; (1 &lt;&lt; n)) printf(&quot;arr[%d] is true.\n&quot;, n); //원소의 존재 확인, 저기서 1과 같냐는 조건을 추가한다면 제대로 동작하지 않습니다.
    
    scanf(&quot;%d&quot;, &amp;n);
    Bitmask |= (1 &lt;&lt; n); //원소 추가
    printf(&quot;%dth(st, nd, rd) element added.\n&quot;, n);
  
    scanf(&quot;%d&quot;, &amp;n);
    Bitmask &amp;= ~(1 &lt;&lt; n); //원소 삭제, 만약 원소가 없으면 그대로
    printf(&quot;%dth(st, nd, rd) element deleted.(if in array)&quot;, n);
    
    scanf(&quot;%d&quot;, &amp;n);
    Bitmask ^= (1 &lt;&lt; n); //원소 토글, if문이 필요 없습니다.
    printf(&quot;%dth(st, nd, rd) element toggled.&quot;, n);

    int Union = (Bitmask | tmp); //합집합, for문 불필요
    
    int Intersection = (Bitmask &amp; tmp); //교집합
    
    int Relative_Component = (Bitmask &amp; ~tmp); //차집합
    
    int Symmetric_Difference = (Bitmask ^ tmp) //대칭차집합
    
    int Complement_Set = ~Bitmask //여집합

    int Min_element = (Bitmask &amp; -Bitmask); //최소원소

    Bitmask &amp;= (Bitmask - 1); //최소원소 지우기

    for(int Sub = Bitmask, i = 1; Sub; Sub = ((Sub - 1) &amp; Bitmask), i++){
        printf(&quot;Subset %d: %d&quot;, i, Sub); //모든 부분집합 순회
    }

    //비트마스킹을 사용할 때는 모든 비트 연산의 주변에 괄호를 치는 것을 추천합니다. 잘못하면 연산자 우선순위 때문에 어이없는 오류가 날 수도 있기 떄문입니다.

}
</code></pre>
<h2><a class="header" href="#코드-설명" id="코드-설명">4. 코드 설명</a></h2>
<p>차근차근 짚어나가 보죠.</p>
<h3><a class="header" href="#원소-확인" id="원소-확인">4.1. 원소 확인</a></h3>
<p>원소 확인은 쉬프트 연산을 통해 1비트의 자리를 설정하고, AND연산을 하여 0인지 0이 아닌 다른 값인지 확인해 줍니다. 이떄, AND연산의 결과가 꼭 1은 아닙니다. 왜냐하면 AND연산은 참 거짓이 아닌 계산의 결과값, 즉 그 자리에 비트가 있다면 2의 거듭제곱을 반환하기 떄문입니다. </p>
<h3><a class="header" href="#원소-추가" id="원소-추가">4.2. 원소 추가</a></h3>
<p>OR연산을 통해 원소를 추가해 줍니다. 설령 이미 원소가 있더라도, 원소는 다르게 바뀌지 않습니다. 있으면 항상 1이기 때문에 1이 1로 바뀌는 것일 뿐입니다. 즉, 변화가 없습니다. </p>
<h3><a class="header" href="#원소-삭제" id="원소-삭제">4.3. 원소 삭제</a></h3>
<p>AND연산을 통해 원소를 삭제해 줍니다. 삭제할 위치의 비트만 1인 상태에서 NOT연산을 취해 준다면 비트가 반전되어 그 비트만 삭제됩니다. 설령 원소가 이미 없더라도 괜찮습니다. 마찬가지로 0이 그대로 0으로 갱신되는 것 뿐입니다. </p>
<h3><a class="header" href="#원소-반전토글" id="원소-반전토글">4.4. 원소 반전(토글)</a></h3>
<p>XOR연산으로 원소를 토글해줍니다. 원소가 1이면 0으로, 0이면 1으로 바꿔준다는 것을 쉽게 알 수 있습니다. 여기서 눈여겨봐야 할 점은, 조건문이 전혀 필요없다는 것입니다. 비트연산 하나로 간단하게 끝낼 수 있다는 점, 이게 바로 비트마스킹의 장점입니다. </p>
<h3><a class="header" href="#합집합" id="합집합">4.5. 합집합</a></h3>
<p>두 집합 사이 OR연산으로 원소가 둘 중 한곳이라도 있다면 전부 있음으로 표시하여 합집합을 계산합니다. </p>
<h3><a class="header" href="#교집합" id="교집합">4.6. 교집합</a></h3>
<p>두 집합 사이 AND연산으로 원소가 두 곳 모두 있다면 있음으로 표시하여 교집합을 계산합니다. </p>
<h3><a class="header" href="#차집합" id="차집합">4.7. 차집합</a></h3>
<p>한 집합을 비트반전(NOT) 반전한 다음 AND 연산으로 원소가 반전한 집합과 반전하지 않은 집합 둘 다 있다면 전부 있음으로 표시하여 차집합을 계산합니다. </p>
<h3><a class="header" href="#대칭차집합" id="대칭차집합">4.8. 대칭차집합</a></h3>
<p>두 집합 사이 XOR연산으로 원소의 유무가 다르다면 전부 있음으로 표시하여 대칭차집합을 계산합니다. </p>
<h3><a class="header" href="#여집합" id="여집합">4.9. 여집합</a></h3>
<p>NOT연산으로 원소를 반전하여 여집합을 계산합니다.</p>
<h3><a class="header" href="#최소-원소-찾기" id="최소-원소-찾기">4.10. 최소 원소 찾기</a></h3>
<p>최소원소 찾기는 비트마스킹의 장점을 다시 한번 보여주는 좋은 예입니다. 위 식은 보수를 이용한 것으로, 보수가 <code>-N-1</code>으로 표현가능함을 이용하여 가장 작은 원소를 손쉽게 계산할 수 있습니다.</p>
<p>또한, 1을 빼면 최소원소 직전의 0들은 모두 1로 반전되고 최소비트 하나만 0으로 반전되기 떄문에 최소비트를 빠르게 뺄 수 있습니다. 최소 원소를 구하고 반전시키는 것보다 훨씬 빠릅니다. </p>
<h3><a class="header" href="#시간복잡도" id="시간복잡도">4.11. 시간복잡도</a></h3>
<p>여기까지 모든 연산의 시간복잡도는 모두 \(O(1)\)입니다.</p>
<h3><a class="header" href="#부분집합-순회" id="부분집합-순회">4.12. 부분집합 순회</a></h3>
<p>마지막으로 부분집합 순회입니다. 저 순회는 다른거에 비해 굉장히 강력합니다. 매우 간단하게 모든 부분집합을 탐색하는 코드를 만들 수 있기 떄문이죠. 먼저 1을 뺀다면 최하위 비트와 그 밑의 0들은 전부 반전됩니다. 그 후 원래 집합과의 교집합을 구한다면, 그 원집합에 속하지 않는 원소들은 모두 꺼지게 됩니다. 그리하여 모든 부분집합을 탐색해나갈 수 있습니다.</p>
<p>시간복잡도는 \(O(2^{N})\)입니다.</p>
<h2><a class="header" href="#예제-1" id="예제-1">5. 예제</a></h2>
<p>비트마스킹은 주로 동적계획법, 즉 다이나믹 프로그래밍과 같이 자주 쓰입니다. 다음 예제를 봅시다. 이 문제는 백준 OJ의 <a href="https://www.acmicpc.net/problem/2098">외판원 순회</a> 문제입니다.</p>
<blockquote>
<p>외판원 순회 문제는 영어로 Traveling Salesman problem (TSP) 라고 불리는 문제로 computer science 분야에서 가장 중요하게 취급되는 문제 중 하나이다. 여러 가지 변종 문제가 있으나, 여기서는 가장 일반적인 형태의 문제를 살펴보자.</p>
<p>1번부터 N번까지 번호가 매겨져 있는 도시들이 있고, 도시들 사이에는 길이 있다. (길이 없을 수도 있다) 이제 한 외판원이 어느 한 도시에서 출발해 N개의 도시를 모두 거쳐 다시 원래의 도시로 돌아오는 순회 여행 경로를 계획하려고 한다. 단, 한 번 갔던 도시로는 다시 갈 수 없다. (맨 마지막에 여행을 출발했던 도시로 돌아오는 것은 예외) 이런 여행 경로는 여러 가지가 있을 수 있는데, 가장 적은 비용을 들이는 여행 계획을 세우고자 한다.</p>
<p>각 도시간에 이동하는데 드는 비용은 행렬 <code>W[i][j]</code>형태로 주어진다. <code>W[i][j]</code>는 도시 <code>i</code>에서 도시 <code>j</code>로 가기 위한 비용을 나타낸다. 비용은 대칭적이지 않다. 즉, <code>W[i][j]</code> 는 <code>W[j][i]</code>와 다를 수 있다. 모든 도시간의 비용은 양의 정수이다. <code>W[i][i]</code>는 항상 0이다. 경우에 따라서 도시 <code>i</code>에서 도시 <code>j</code>로 갈 수 없는 경우도 있으며 이럴 경우 <code>W[i][j] = 0</code>이라고 하자.</p>
<p>N과 비용 행렬이 주어졌을 때, 가장 적은 비용을 들이는 외판원의 순회 여행 경로를 구하는 프로그램을 작성하시오.</p>
<hr />
<p><strong>입력</strong></p>
<p>첫째 줄에 도시의 수 <code>N</code>이 주어진다. (\(2 \leq N \leq 16)\) 다음 <code>N</code>개의 줄에는 비용 행렬이 주어진다. 각 행렬의 성분은 1,000,000 이하의 양의 정수이며, 갈 수 없는 경우는 0이 주어진다. <code>W[i][j]</code>는 도시 <code>i</code>에서 <code>j</code>로 가기 위한 비용을 나타낸다.</p>
<p>항상 순회할 수 있는 경우만 입력으로 주어진다.</p>
<hr />
<p><strong>출력</strong></p>
<p>첫째 줄에 외판원의 순회에 필요한 최소 비용을 출력한다.</p>
<hr />
<p><strong>입출력 예시</strong></p>
<hr />
<p><em><strong>Input</strong></em></p>
<p><em>4</em></p>
<p><em>0 10 15 20</em></p>
<p><em>5  0  9 10</em></p>
<p><em>6 13  0 12</em></p>
<p><em>8  8  9  0</em></p>
<hr />
<p><em><strong>Output</strong></em></p>
<p><em>35</em></p>
</blockquote>
<p>이 문제의 풀이 방법은 비트마스크와 다이나믹 프로그래밍입니다. 먼저 시작 도시를 정한 후, 그 도시로 부터 갈 수 있는 방법을 완전탐색 해 나갑니다. 이떄, 그냥 일반적인 완전탐색은 시간이 엄청나게 오래 걸리므로, 다이나믹 프로그래밍을 사용합니다. 점화식은 다음과 같습니다.</p>
<p>\(TSP(curr, visited) = min(TSP(next, visited \cup next) + dist[curr][next]) \)</p>
<p>\((0 \leq next \leq N - 1, next \neq curr, next \notin visited)\)</p>
<p>현재 도시의 순회 최솟값을 알기 위해 다음 돌아가는 모든 경로를 탐색한 후 그 값을 DP에 저장하면 문제가 풀릴 수 있습니다. 이떄, 집합 visited를 비트마스킹으로 구현할 수 있습니다.</p>
<p>이 코드는 DP의 원소의 개수가 \(2^{N} \times N\)이고 이를 각 도시마다 한 번씩 N번 탐색하여 총 시간복잡도는 \(O(2^{N} \times N^{2})\)입니다. 만약 다이나믹기법을 쓰지 않았다면 모두 일일이 탐색해야 하므로 시간복잡도는 \(O(N!)\)이 되었을 것입니다. 느리기는 하지만, 확실히 빨라졌습니다. 여기에 비트마스킹으로 연산속도까지 빨라졌으니, 문제에서 주어진 <code>N</code>의 범위쯤은 거뜬합니다.</p>
<h1><a class="header" href="#bit-operator" id="bit-operator">Bit Operator</a></h1>
<h2><a class="header" href="#소개-28" id="소개-28">1. 소개</a></h2>
<p>비트 연산자란, 각 수의 비트로(즉, 0과 1로) 연산을 진행하는 연산자입니다. 비트 연산자는 다음과 같이 있습니다.</p>
<ul>
<li>비트 AND(&amp;)</li>
<li>비트 OR(|)</li>
<li>비트 XOR(^)</li>
<li>비트 LSHIFT(&lt;&lt;), RSHIFT(&gt;&gt;)</li>
<li>비트 NOT(~)</li>
</ul>
<p>비트 연산자를 사용하면 좋은 점이 무엇일까요? 그 이유는 연산속도가 빨라지기 때문입니다. 비트연산은 일반 사칙연산 연산자와는 달리 연산속도가 빨라 시간단축에 용이할 수 있습니다. 시간단축은 알고리즘 문제를 풀때 매우 중요한 요소라는 것은 독자 여러분들도 잘 알고 있을 것입니다.</p>
<h2><a class="header" href="#bit-and" id="bit-and">2. BIT AND</a></h2>
<p>비트 AND연산자는 같은자리의 Bit를 비교하여 둘다 1이면 그 자리에 1을, 둘 중 하나라도 1이 아니면 0을 계산 결과로 내놓아 하나의 수를 만듭니다. Bit 연산이므로 2진수를 기준으로 연산하며, 일반 사칙연산보다 그 속도가 빠릅니다. 예를 들어 다음 코드를 보면</p>
<pre><code class="language-c++">printf(&quot;%d\n&quot;, 23 &amp; 9); //1
printf(&quot;%d\n&quot;, 22 &amp; 11); //2
printf(&quot;%d\n&quot;, 31 &amp; 31); //31
</code></pre>
<p>같은 연산을 할 수 있습니다.</p>
<p>맨 위의 식을 예로 들어본다면 23은 이진수로 \(10111_{(2)}\)이고 9는 이진수로 \(1001_{(2)}\)이기 때문에 &amp;연산을 취해준다면</p>
<img src="datastructure/intermediate/bitoperator/./bitoperator1.png" width = 200 >
<p>와 같이 됩니다.</p>
<p>그렇다면 논리 AND와의 다른점은 어떻게 될까요? </p>
<p>다음 코드를 봅시다.</p>
<pre><code class="language-c++">if(3 &amp; 1) printf(&quot;Bit says true.\n&quot;);
if(3 &amp;&amp; 1) printf(&quot;Logic says true.\n&quot;);
</code></pre>
<p><code>3 &amp; 1</code>을 계산하면 0이 나온다는 것을 어렵게 알 수 있어 첫번째 if문은실행이 되지 않습니다. 그러나 두번째 if문은 0이 아닌 두 값을 논리 AND연산을 하였기 때문에 참이 됩니다. 따라서 두번째 if문만 실행됩니다.</p>
<p>정리하자면 논리 AND는 <strong>0이면 false, 그 이외의 값이라면 true로 판단하여 연산을 진행하지만,</strong> 비트 AND는 __각 비트마다 0, 1로 연산을 진행한다는 점__을 염두에 두어야 합니다. 이는 논리연산과 비트연산의 중요한 차이점이니 꼭 짚고 넘어갑시다.</p>
<h2><a class="header" href="#bit-or" id="bit-or">3. BIT OR</a></h2>
<p>비트 OR연산자는 같은자리의 Bit를 비교하여 둘다 0이면 그 자리에 0을, 둘 중 하나라도 0이 아니면 1을 계산 결과로 내놓아 하나의 수를 만듭니다. 예를 들어 다음 코드를 보면</p>
<pre><code class="language-c++">printf(&quot;%d\n&quot;, 23 | 9); //31
printf(&quot;%d&quot;, 2 | 1); //3
printf(&quot;%d\n&quot;, 31 | 31); //31
</code></pre>
<p>같은 연산을 할 수 있습니다</p>
<p>마찬가지로 맨 위의 식을 예로 들어본다면</p>
<img src="datastructure/intermediate/bitoperator/./bitoperator2.png" width = 200 >
<p>와 같이 됩니다.</p>
<p>논리 OR는 마찬가지로 0이면 false, 그 이외에는 전부 true를 기준으로 연산을 진행합니다. 다음 코드를 봅시다.</p>
<pre><code class="language-c++">if(1 | 0 == true) printf(&quot;Bit is true.\n&quot;); //true

if(1230 || 0 == true) printf(&quot;Logic is true.\n&quot;); //true
</code></pre>
<h2><a class="header" href="#bit-xor" id="bit-xor">4. BIT XOR</a></h2>
<p>비트 XOR연산자는 같은자리의 Bit를 비교하여 그 비트가 서로 같다면 그 자리에 0을, 다르다면 1을 계산 결과로 내놓아 하나의 수를 만듭니다. 예를 들어</p>
<pre><code class="language-c++">printf(&quot;%d\n&quot;, 23 ^ 9); //30
printf(&quot;%d\n&quot;, 2 ^ 1); //3
printf(&quot;%d\n&quot;, 31 ^ 31); //0
</code></pre>
<p>를 만족합니다.</p>
<p>가장 위의 식을 또 예로 들어본다면</p>
<img src="datastructure/intermediate/bitoperator/./bitoperator3.png" width = 200 >
<p>와 같이 됩니다.</p>
<p>여담으로, 제곱을 나타내는 기호라고 생각하면 안됩니다. 제곱을 구하는 함수는 따로 있습니다.</p>
<h2><a class="header" href="#bit-shift" id="bit-shift">5. BIT SHIFT</a></h2>
<p>비트 SHIFT 연산은 위의 연산과 성격이 좀 다릅니다. 위에 있는 연산들은 교환법칙이 성립했다면, 이 연산은 교환법칙이 성립할 수 없습니다. 이 연산은 첫 번째 숫자를 두 번째 숫자만큼 비트단위에서 왼쪽/오른쪽으로 미는 것입니다.</p>
<p>그럼 정확하게 민다는 것이 무슨 뜻일까요? 다음 코드를 봅시다.</p>
<pre><code class="language-c++">printf(&quot;%d\n&quot;, 20 &gt;&gt; 2); //5

printf(&quot;%d\n&quot;, -6 &gt;&gt; 2); //-1

printf(&quot;%d\n&quot;, 12 &lt;&lt; 3); //96
</code></pre>
<p>첫번째 예를 살펴봅시다. 20은 이진수로 \(10100_{(2)}\) 입니다. 이 수를 오른쪽으로 두번 shift하면 5, 즉 \(101_{(2)}\)이 된다는 것을 쉽게 알 수 있습니다.</p>
<p>그러면, RSHIFT 연산후, 가장 왼쪽 비트에 나오는 숫자는 무엇일까요? 다음 예를 살펴봅시다.</p>
<p>-6을 이진수로 표현한다면(32비트 정수 기준) \(1111 1111 1111 1111 1111 1111 1111 1010_{(2)}\)입니다. 만약 shift 후 왼쪽에 0이 채워진다면, 첫번째 연산은 그대로 5이지만, 이 연산은 음수가 양수로 바뀌면서 약 10억정도에 가까운 숫자가 만들어지게 됩니다. 그러나, 실제 계산해보면 이 연산의 결과는 -1이 나옵니다. 즉, <strong>RSHIFT연산 후 왼쪽에 채워지는 비트는 연산 전에 원래 있었던 비트를 채운다는</strong> 거죠. </p>
<p>LSHIFT 연산에 경우는 왼쪽으로 shift하면서 오른쪽에 0을 채웁니다. 여기서 눈여겨 볼 점은, 정수 N을 M번 shift 했을때, 계산 결과가 \(N \times 2^{M}\)으로 나온다는 것이죠. 그렇다면 RSHIFT는 어떨까요? 그 연산은 실행시켜보면 \(N\)을 \(2^{M}\)으로 나눈 몫이 나옵니다. 곧, SHIFT 연산은 <strong>어떤 숫자를 2의 거듭제곱만큼 곱하거나 나눈 결과값을 반환한다고 할 수 있습니다.</strong></p>
<h2><a class="header" href="#bit-not" id="bit-not">6. BIT NOT</a></h2>
<p>비트 NOT연산자는 위의 연산자들과는 달리 단항연산자입니다. 단항연산자란, 하나의 수에 적용되는, 사칙연산보다는 부호연산과 더 가깝다고 할 수 있는 연산자 입니다. 이 연산자가 어떤 수 앞에 붙는다면 그 수의 비트를 전부 반대로 바꿔줍니다. 다음 코드를 살펴봅시다.</p>
<pre><code class="language-c++">printf(&quot;%d&quot;, ~10); //-11
</code></pre>
<p>갑자기 NOT연산의 결과를 통해 부호가 바뀌어서 당황스러울 수 있습니다. 그러나 이건 매우 당연한 것입니다. 첫번째 비트는 부호를 결정하기 때문에 그 비트까지 바뀌어서 부호가 바뀐 것입니다.</p>
<p>이 NOT연산은 특징이 있습니다. <code>~N</code>은 항상 <code>-N-1</code>이 됩니다. 이 결과는 비트 반전하여 계산하면 쉽게 알 수 있는데, <strong>이 비트 NOT연산을 한 수를 그 수의 보수라고 합니다.</strong></p>
<h1><a class="header" href="#heap" id="heap">Heap</a></h1>
<h2><a class="header" href="#소개-29" id="소개-29">1. 소개</a></h2>
<p>힙이란 특정한 규칙을 만족하도록 구성된 완전이진트리로써, 최댓값 및 최솟값을 빠르게 찾기 위해 고안되었습니다. 완전이진트리가 무엇인지는 RB tree 단원에서 배웠을 것이라고 생각하고 바로 힙에 대한 설명으로 넘어가겠습니다. 힙은 부모와 자식 사이에 일정한 대소관계 규칙이 있는 트리입니다. 따라서 뿌리노드에는 항상 가장 높은(또는 가장 작은) 우선순위의 노드가 위치하게 됩니다. 부모가 항상 자식보다 크거나 같은 경우는 최대 힙(max heap)이라고 하고 그 반대의 경우는 최소 힙(min heap)이라고 합니다. 이렇게 만들어 놓으면 주어진 값들의 최솟값이나 최댓값을 바로 알 수 있습니다. min heap의 경우 뿌리노드가 최솟값이고, max heap의 경우는 최댓값이겠지요.</p>
<img src="datastructure/intermediate/heap/./heap1.PNG" width = 500 >
<p>위 그림은 전형적인 최소 힙의 모습입니다. 그림을 보면 항상 부모노드가 자식노드보다 작으므로 이것은 최소 힙(min heap) 이라고 할 수 있겠습니다.</p>
<h2><a class="header" href="#연산" id="연산">2. 연산</a></h2>
<p>힙에서는 삽입(push)과 삭제(pop) 연산을 할 수 있습니다. </p>
<h3><a class="header" href="#push" id="push">2.1. Push</a></h3>
<p>삽입을 할 때는 완전이진트리의 형태가 유지되도록 가장 마지막 위치에 저장을 하고, 부모와 비교를 해 가며 min heap의 경우 부모가 새로 추가된 자식보다 큰 경우 이 둘을 교환하는 식으로 알맞은 자리를 찾아가게 합니다.</p>
<p><img src="datastructure/intermediate/heap/./insert3.PNG" width = 300 ><img src="datastructure/intermediate/heap/./insert2.PNG" width = 300 ><img src="datastructure/intermediate/heap/./insert1.PNG" width = 300 ></p>
<p>위 그림은 아까의 Heap에 3을 삽입(push)한 경우를 나타낸 것입니다. 완전이진트리의 끝에 삽입된 3은 부모인 7보다 작으므로 min heap의 성질을 유지시키기 위해 이 둘을 바꿉니다. 그 뒤 3과 새로운 부모인 4를 비교해 이 둘을 바꿉니다. 이렇게 생긴 새로운 부모인 1은 3보다 작으므로 3의 위치는 현재 자리로 확정이 됩니다. 이 교환 과정에서 걸리는 시간은 최대가 트리의 깊이이고, 따라서 삽입 연산의 시간복잡도는 \(O(\log n)\)이 됩니다.</p>
<h3><a class="header" href="#pop" id="pop">2.2. Pop</a></h3>
<p>삭제를 할 때는 완전이진트리의 뿌리에 있는 값을 pop 한 후 가장 끝에 있는 노드를 루트 노드로 가져온 뒤 두 자식들과 비교해 힙의 성질을 유지시키도록 만듭니다.</p>
<p><img src="datastructure/intermediate/heap/./pop1.PNG" width = 300 ><img src="datastructure/intermediate/heap/./pop2.PNG" width = 300 ><img src="datastructure/intermediate/heap/./pop3.PNG" width = 300 ><img src="datastructure/intermediate/heap/./pop4.PNG" width = 300 ></p>
<p>위 그림은 아까의 Heap에서 pop연산을 하는 경우를 나타낸 것입니다. 먼저 뿌리노드의 1이 삭제되고 그 자리를 맨 끝에있는 7이 채웁니다. 그 뒤 자식과 비교하였을 때 2가 3,7보다 작으므로 2와 7의 위치를 바꾸고, 새로운 7의 위치에 대해 이것을 반복하여 7이 자식들보다 더 작아질 때까지 이것을 반복합니다. 이렇게 하면 가장 작은 원소를 빼내면서 Heap의 구조를 유지시킬 수 있습니다. 마찬가지로 pop도 시간복잡도가 \(O(\log n)\)이 됩니다.</p>
<h2><a class="header" href="#구현" id="구현">3. 구현</a></h2>
<p>힙을 실제로 C++에서 구현할 때는 주로 1차원 배열이 사용됩니다. <code>a</code>이라는 배열이 있다고 하고 <code>a[1]</code>을 루트 노드로 지정하면 힙은 완전이진트리이기 때문에 <code>a[n]</code>을 부모로 하는 자식들은 <code>a[n*2]</code>와 <code>a[n*2+1]</code>임을 알 수 있습니다. 따라서 어떤 위치 <code>a[n]</code>에 대해 자식은 <code>a[n*2]</code>와 <code>a[n*2+1]</code>, 부모는 <code>a[n/2]</code>로 쉽게 위치를 특정할 수 있습니다.</p>
<img src="datastructure/intermediate/heap/./heap2.PNG" width = 500 >
<p>이렇게 배열로 Heap을 구현하는 경우 먼저 부모와 자식 사이에 대소관계규칙이 성립하는지 판단하는 함수를 만들 수 있습니다.</p>
<pre><code class="language-c++">bool comp(int parent, int son){
    if (parent &lt;= son)
        return true;
    else
        return false;
}
</code></pre>
<p>그리고 아래와 같이 push를 구현할 수 있습니다.</p>
<pre><code class="language-c++">void update(int ind){
    if (ind == 1 || comp(heap[ind / 2], heap[ind]))
        return;
    swap(heap[ind], heap[ind / 2]);
    return update(ind / 2);
}
void push(int k){
    heap[sizz] = k;
    update(sizz);
    sizz++;
}
</code></pre>
<p>그리고 pop은</p>
<pre><code class="language-c++">void update2(int ind){
    if (ind * 2 &gt; sizz)
        return;
    if (ind * 2 == sizz || comp(heap[ind * 2], heap[ind * 2 + 1])){
        if (comp(heap[ind], heap[ind * 2]))
            return;
        swap(heap[ind], heap[ind * 2]);
        return update2(ind * 2);
    }
    if (comp(heap[ind], heap[ind * 2 + 1]))
        return;
    swap(heap[ind], heap[ind * 2 + 1]);
    return update2(ind * 2 + 1);
}
int pop(){
    int re = heap[1];
    if (sizz == 1)
        return 0;
    heap[1] = heap[sizz-1];
    sizz--;
    update2(1);
    return re;
}
</code></pre>
<p>이렇게 구현이 가능합니다.</p>
<h2><a class="header" href="#예제-2" id="예제-2">4. 예제</a></h2>
<blockquote>
<p><a href="https://www.acmicpc.net/problem/11286">문제</a></p>
<p>절댓값 힙은 다음과 같은 연산을 지원하는 자료구조이다.</p>
<ol>
<li>배열에 정수 x (x ≠ 0)를 넣는다.</li>
<li>배열에서 절댓값이 가장 작은 값을 출력하고, 그 값을 배열에서 제거한다. 절댓값이 가장 작은 값이 여러개일 때는, 가장 작은 수를 출력하고, 그 값을 배열에서 제거한다.</li>
<li>프로그램은 처음에 비어있는 배열에서 시작하게 된다.</li>
</ol>
<hr />
<p>입력</p>
<p>첫째 줄에 연산의 개수 N(1≤N≤100,000)이 주어진다. 다음 N개의 줄에는 연산에 대한 정보를 나타내는 정수 x가 주어진다. 만약 x가 0이 아니라면 배열에 x라는 값을 넣는(추가하는) 연산이고, x가 0이라면 배열에서 절댓값이 가장 작은 값을 출력하고 그 값을 배열에서 제거하는 경우이다. 입력되는 정수는 -231보다 크고, 231보다 작다.</p>
<hr />
<p>출력</p>
<p>입력에서 0이 주어진 회수만큼 답을 출력한다. 만약 배열이 비어 있는 경우인데 절댓값이 가장 작은 값을 출력하라고 한 경우에는 0을 출력하면 된다.</p>
</blockquote>
<p>이 문제는 매우 간단한 Heap 예제입니다. 이 문제는 아까 구현한 코드에서 comp 함수의 비교 기준을 절댓값으로 살짝 바꿔주시기만 하면 됩니다.</p>
<h2><a class="header" href="#priority-queue-1" id="priority-queue-1">5. Priority Queue</a></h2>
<p>하지만 힙을 매번마다 구현하기는 어렵습니다. 그래서 실전에서 문제를 풀 때는 stl에 있는 <code>priority_queue</code>를 사용하는 것을 추천합니다. <code>priority_queue</code>는 <code>&lt;queue&gt;</code> 헤더에 있습니다. <code>priority_queue</code>는
<code>priority_queue &lt;자료형&gt; mypq</code>
로 선언하며, 사용할 수 있는 함수는 힙에 <code>k</code>라는 값을 push하는  <code>mypq.push(k)</code>, pop을 진행하는 <code>mypq.pop(),</code> 힙이 비어있으면 true를 반환하는 <code>mypq.empty()</code>, 루트노드에 있는 원소를 반환하는 <code>mypq.top()</code> 등이 있습니다.</p>
<h1><a class="header" href="#red-black-tree" id="red-black-tree">Red Black Tree</a></h1>
<h1><a class="header" href="#tree" id="tree">Tree</a></h1>
<h2><a class="header" href="#소개-30" id="소개-30">1. 소개</a></h2>
<h2><a class="header" href="#관련-알고리즘-1" id="관련-알고리즘-1">2. 관련 알고리즘</a></h2>
<ul>
<li><a href="datastructure/tree/./disjointset/disjointset.html">Disjoint Set</a>
<ul>
<li><a href="datastructure/tree/./disjointset/prim/prim.html">Prim Algorithm</a></li>
<li><a href="datastructure/tree/./disjointset/kruskal/kruskal.html">Kruskal Algorithm</a></li>
</ul>
</li>
<li><a href="datastructure/tree/./topologicalsort/topologicalsort.html">Topological Sort</a></li>
<li><a href="datastructure/tree/./eulertour/eulertour.html">Euler Tour</a></li>
<li><a href="datastructure/tree/./diameter/diameter.html">Tree Diameter</a></li>
<li><a href="datastructure/tree/./lca/lca.html">LCA</a></li>
<li><a href="datastructure/tree/./cactus/cactus.html">Cactus Graph</a></li>
</ul>
<h1><a class="header" href="#disjoint-set" id="disjoint-set">Disjoint Set</a></h1>
<h1><a class="header" href="#prim-algorithm" id="prim-algorithm">Prim Algorithm</a></h1>
<h1><a class="header" href="#kruskal-algorithm" id="kruskal-algorithm">Kruskal Algorithm</a></h1>
<h1><a class="header" href="#topological-sort" id="topological-sort">Topological Sort</a></h1>
<h2><a class="header" href="#소개-31" id="소개-31">1. 소개</a></h2>
<p>Topological Sort는 위상 정렬이라고 하며, 방향 그래프에서 정점들을 정점 u에서 정점 v로 가는 간선이 있을 때, 정점 u가 정점 v보다 앞에 오도록 선형으로 정렬하는 것입니다. 이렇게 정점들을 정렬하면 어떤 작업을 수행할 때 올바른 순서를 알아낼 수 있습니다. 예를 들어, 수강해야 할 여러 수업들 중 한 수업보다 먼저 들어야 하는 수업이 있을 때, 위상 정렬을 이용하면 가능한 수강 순서를 알아낼 수 있을 것입니다. 그러나 이러한 위상 정렬을 하려면, 정렬하려고 하는 그래프가 사이클이 없는 방향성 비순환 그래프 (directed acyclic graph 또는 DAG) 이어야 합니다. 당연하게도 사이클이 존재한다면 사이클을 이루는 정점 간의 우선 순위를 결정할 수 없기 때문입니다. 그리고 정렬이 된 순서는 그래프의 구조에 따라 여러 종류가 나올 수 있게 됩니다.</p>
<p>실제 컴퓨터 분야에서 이 알고리즘은 논리 합성, 데이터 직렬화, 코드 최적화의 한 방법인 Instruction Scheduling 등에서 사용됩니다. </p>
<h2><a class="header" href="#kahns-algorithm" id="kahns-algorithm">2. Kahn's Algorithm</a></h2>
<p>가장 대표적이고 많이 쓰이는 위상 정렬 알고리즘은 Kahn 이라는 사람이 처음 설명했다고 합니다. 먼저 indegree_(진입 차수 : 한 정점으로 향하는 간선의 개수)_가 0인 정점을 모두 찾습니다. 그리고 이 정점들을 그래프에서 제거합니다. 제거함에 따라 생기는 indegree가 0인 정점들을 다시 찾아 위 두 과정을 반복합니다. 이 과정을 그래프에서 정점이 없어질 때까지 수행한 뒤, 제거했던 순서대로 정점을 배열하면 위상 정렬이 완료됩니다. 이를 구현해보면 다음과 같습니다. 여기서 L은 앞으로 정렬된 정점 번호가 들어갈 배열이고, 현재는 비어있습니다. S는 queue 이고 정점 중 가리키는 간선의 개수가 0인 정점이 들어가게 됩니다.</p>
<pre><code class="language-c++">for(n : node){
 if(indegree[n]==0){
   S.push_back(n);
 }
}
while(!S.empty()){
 n = S.back(); S.pop_back();
 L.push_back(n);
 for(m : graph[n]){
   indegree[m]--;
   if(indegree[m]==0){
     S.push_back(m);
   }
 }
}
if(L.size()!=N)	return error;	// graph has at least one cycle
else	return L;	// a topologically sorted order
</code></pre>
<p>이 알고리즘은 시간복잡도가 \(O(V+E)\)로, 정점의 개수와 간선의 개수를 더한 것이 됩니다. 그 이유는 <code>S</code>에서 노드를 총 <code>n</code>번 꺼내게 되어 \(O(V)\), 모든 간선을 한 번씩 제거해서 \(O(E)\)가 되기 때문입니다.</p>
<h2><a class="header" href="#using-dfs" id="using-dfs">3. Using DFS</a></h2>
<p>잘 알려진 깊이 우선 탐색(dfs, depth-first search)을 이용해도 위상 정렬을 할 수 있습니다. 그러나 dfs를 시작하는 정점은 꼭 indegree가 0인 정점이 아니어도 되고, 재귀호출을 한 함수가 끝날 때 값을 배열 L에 넣으면 됩니다. 이 때 위상 정렬한 결과는 배열 L에서 역순으로 뒤집어 준 것과 같다는 점을 유의해야 합니다. 그래서 배열 대신 Stack이라는 자료 구조를 활용하는 것도 가능합니다. 이를 구현해보면 다음과 같습니다.</p>
<pre><code class="language-c++">void visit(Node n){
  if(per[n])	return;
  if(tem[n])	stop();		// not DAG
  tem[n] = true;
  for(m : graph[n]){
    visit(m);
  }
  tem[n] = false;
  per[n] = true;
  L.push_back(L);
}

void topological_sort(){
  for(n : node){
    if(!per[n]){
      visit(n);
    }
  }
  return L;
}
</code></pre>
<p>이 코드의 시간복잡도는 위와 마찬가지로 선형인 \(O(n)\)입니다. 그러나 위의 코드보다는 조금 오래 걸릴 것입니다. 또한 이 알고리즘은 직관적인 이해가 보다 쉽지 않습니다. 그래서 일반적으로 위상 정렬만 할 경우에는 위의 알고리즘을 쓰게 됩니다. 그러나 dfs를 활용해서도 위상 정렬을 할 수 있다는 사실 정도는 알아두면 좋을 것입니다.</p>
<h2><a class="header" href="#finding-a-shortest-path" id="finding-a-shortest-path">4. Finding a Shortest Path</a></h2>
<p>위상 정렬을 이용하면 DAG에서 최단 경로도 빠르게 찾아낼 수 있습니다. 위상 정렬을 한 결과를 저장한 배열이 있을 때 배열 위의 정점 s에서 배열 끝까지, 각 정점마다 간선으로 연결된 다른 정점까지의 최단 경로를 갱신해주면 됩니다. 이를 구현해보면 다음과 같습니다. 여기서 배열 <code>V</code>는 위상 정렬을 한 결과가 들어가있고, 배열 <code>d[u]</code>에는 정점 <code>s</code>에서 정점 <code>u</code>까지의 최단 경로가 들어가게 될 것입니다. 그리고 <code>w</code>는 <code>u</code>에서 <code>v</code>로 향하는 간선의 가중치를 의미합니다.</p>
<pre><code class="language-c++">d[s] = 0;

for(u : node){
   if(u!=s)	d[u] = INF;
}

for(u : V){
 for(v : graph[u]){
   if(d[v] &gt; d[u] + w)	d[v] = d[u] + w;
 }
}
</code></pre>
<p>이 알고리즘은 위상 정렬을 할 때와 마찬가지로 시간복잡도가 \(O(V+E)\)입니다. 따라서 선형이므로 꽤나 빠르게 최단 경로를 찾을 수 있습니다. 그러나 이와 비슷한 시간복잡도를 가지고 좀 더 간결하게 코드를 짤 수 있는 dijkstra 알고리즘을 사용하는 것이 실전에서는 더 도움이 될 것입니다.</p>
<h2><a class="header" href="#예시-3" id="예시-3">5. 예시</a></h2>
<p>위상 정렬을 사용하여 해결할 수 있는 문제 중 대표적인 문제로는 <a href="https://www.acmicpc.net/problem/2252">줄 세우기</a>가 있습니다. 이 문제는 vector 자료구조로 인접 리스트를 만들어 위상 정렬을 수행하면 바로 답을 구할 수 있습니다. 이에 대한 코드는 다음과 같습니다.</p>
<pre><code class="language-c++">int main(void) {
   for(i = 1; i &lt;= m; i++) {
   	scanf(&quot;%d %d&quot;, &amp;p, &amp;q);
   	V[p].push_back(q);
   	idg[q]++;
   }
   for(i = 1; i &lt;= n; i++)
   	if(idg[i] == 0)
   		Q.push(i);
 
   while(!Q.empty()) {
     u = Q.front();
     Q.pop();
     ans[++cnt] = u;
     siz = V[u].size();
     for(i = 0; i &lt; siz; i++) {
       v = V[u][i];
       idg[v]--;
       if(idg[v] == 0)
         Q.push(v);
     }
   }

   for(i = 1; i &lt;= cnt; i++)
     printf(&quot;%d &quot;, ans[i]);
   
   return 0;
}
</code></pre>
<h1><a class="header" href="#euler-tour" id="euler-tour">Euler Tour</a></h1>
<h1><a class="header" href="#tree-diameter" id="tree-diameter">Tree Diameter</a></h1>
<h1><a class="header" href="#lca" id="lca">LCA</a></h1>
<h1><a class="header" href="#cactus-graph" id="cactus-graph">Cactus Graph</a></h1>
<h1><a class="header" href="#segment-tree" id="segment-tree">Segment Tree</a></h1>
<h2><a class="header" href="#소개-32" id="소개-32">1. 소개</a></h2>
<p>Segment Tree는 STL에서 지원하지 않는 자료구조이지만 아주 강력한 자료구조중 하나입니다. Segment Tree는 일반적으로 \(O(\log N)\)시간에 값의 변경과 값에 대한 쿼리를 수행할 수 있고, 그 활용성 또한 아주 다양해 구간 합 쿼리, 구간 최솟값/최댓값 쿼리등을 수행할 수 있습니다.</p>
<p>Segment Tree의 유래를 찾아보자면 버킷에서 찾아볼 수 있다고 할 수 있습니다. 다음 그림은 원소 2개당 하나의 버킷을 만들어 최솟값을 저장한 모습입니다.</p>
<img src="datastructure/segmenttree/./segment1.pdf" width = 400 >
<p>RMQ쿼리를 처리할 때, 그림과 같이 \(\lceil N/2 \rceil\) 개의 버킷을 생각해봅시다. 그리고 이 버킷들은 두 원소중 작은 원소의 값을 가지고 있습니다.
그렇다면 어떤 구간의 RMQ쿼리를 처리할 때에는, 봐야 하는 값이 반으로 줄어들게 됩니다. 그리고 값을 갱신하면 자기 자신과, 자신을 포함하는 버킷을 갱신해주면 되겠죠. </p>
<p>이것을 더 빠르게 하고 싶다면 버킷의 버킷을 만들 수 있습니다. 이런 방법을 사용한다면 봐야 하는 값의 개수가 더욱 줄어들게 되겠죠. 하지만 이런 방법으로는 시간 복잡도에는 영향이 없습니다. </p>
<p>하지만 이 과정을 계속 반복한다면 봐야 하는 값의 개수가 크게 줄어들 것입니다. 이런 아이디어의 연장이 Segment Tree라고 할 수 있습니다. Segment Tree는 저 과정을 계속 반복해 그림과 같이 한 원소는 약 \(\log N\) 개의 노드의 부분에 속하게 됩니다.</p>
<img src="datastructure/segmenttree/./segment2.pdf" width = 400 >
<p>또한 어떤 구간을 선택했을 때, 봐야 하는 노드의 개수 또한 \(O(\log N)\) 개가 되어 쿼리를 \(O(\log N)\) 안에 처리할 수 있게 됩니다. 이것은 자명한 것이, 한 높이에 3가지 이상의 노드를 봐야 한다고 하면 그 3가지중 2가지를 합쳐서 위의 노드를 하나 보는 것으로 대신할 수 있기 때문에 모순이 되어 한 높이에서 최대 볼 수 있는 노드의 개수는 2개가 되기 때문입니다. </p>
<h2><a class="header" href="#예시-4" id="예시-4">2. 예시</a></h2>
<p>Segment Tree를 사용하여 <a href="https://www.acmicpc.net/problem/2042">아주 기본적인 부분 합 쿼리 문제</a>를 처리해보자. 문제를 요약하면 다음과 같다.</p>
<blockquote>
<p>어떤 <code>N</code>개의 수가 주어져 있다. 그런데 중간에 수의 변경이 <code>M</code>번 일어나고 그 중간에 어떤 부분의 합을 <code>K</code>번 구하려 한다. </p>
<p>\(N\leq1,000,000, M\leq10,000, K\leq10,000\)</p>
<p>첫째 줄에 수의 개수  <code>N</code>, 수의 변경이 일어나는 횟수 <code>M</code>,부분의 합을 구해야 하는 횟수 <code>K</code>가 입력된다.</p>
<p>그리고 둘째 줄부터 <code>N+1</code>번째 줄까지 <code> N</code>개의 수가 주어진다.</p>
<p><code>N+2</code>번째 줄부터 <code>N+M+K+1</code>번째 줄까지 세 개의 정수 <code>a</code>,<code>b</code>,<code>c</code>가 주어지는데, <code>a</code>가 1인 경우 <code>b</code>번째 수를 <code>c</code>로 바꾸고 <code>a</code>가 2인 경우에는 <code>b</code>번째 수부터 <code>c</code>번째 수까지의 합을 구하여 출력하면 된다.</p>
</blockquote>
<p>간단한 구간 합 문제이므로 Segment Tree를 이용해 해결할 수 있습니다.</p>
<p>Segment Tree를 구현할 때, 대략 2가지 방법이 있는데, 재귀함수를 이용하는 방법을 사용해보겠습니다.</p>
<pre><code class="language-c++">#include &lt;bits/stdc++.h&gt;

using namespace std;
typedef long long int ll;

ll tree[4400000]; //it is safe to have size*4
ll arr[1100000];
int N,M,K;
void init(int s,int e,int node){
    if(s==e) tree[node]=arr[s]; //leaf node
    else{
        int m=(s+e)&gt;&gt;1;
        init(s,m,node*2);
        init(m+1,e,node*2+1); //recursive
        tree[node]=tree[node*2]+tree[node*2+1];
    }
}
ll range(int s,int e,int node,int l,int r){//l~r
    if(e&lt;l||r&lt;s) return 0;//not in range
    if(l&lt;=s&amp;&amp;e&lt;=r) return tree[node]; // node range inside l~r
    int m=(s+e)&gt;&gt;1;
    return range(s,m,node*2,l,r)+range(m+1,e,node*2+1,l,r); //calls its leaf
}
void update(int s,int e,int node,int pos,int val){
    if(pos&lt;s||e&lt;pos) return ;
    if(s==e){
        tree[node]=val;
        return ;
    }
    int m=(s+e)&gt;&gt;1;
    update(s,m,node*2,pos,val);
    update(m+1,e,node*2+1,pos,val);
    tree[node]=tree[node*2]+tree[node*2+1];//update its value
}



int main(){
    scanf(&quot;%d %d %d&quot;,&amp;N,&amp;M,&amp;K);
    for(int i=1;i&lt;=N;i++){
        scanf(&quot;%lld&quot;,&amp;arr[i]);
    }
    init(1,N,1);
    for(int i=0;i&lt;M+K;i++){
        int a,b,c;
        scanf(&quot;%d %d %d&quot;,&amp;a,&amp;b,&amp;c);
        if(a==1){
            update(1,N,1,b,c);
        }
        else{
            printf(&quot;%lld\n&quot;,range(1,N,1,b,c));
        }
    }
    return 0;
}
</code></pre>
<p>tree의 크기는 그 트리가 담당하는 구간의 4배 정도로 하면 안전합니다.
<code>s</code>,<code>e</code>는 그 트리가 담당하는 구간이고 <code>node</code>는 그 트리의 번호입니다. tree의 왼쪽 자식을 나타낼 때에는 (원래 번호)*2를 해주고, 오른쪽 자식을 나타낼 때에는 (원래 번호)*2+1을 해 주어 노드 번호를 변화시킵니다. <code>update</code>나 <code>range</code>의 특징은 범위에 자신이 해당되지 않거나 완벽히 해당되면 바로 <code>return </code>한다는 것입니다. 이 특징 때문에 쿼리당 시간 복잡도는 \(O(\log N)\)입니다.</p>
<h2><a class="header" href="#관련-자료구조" id="관련-자료구조">3. 관련 자료구조</a></h2>
<ul>
<li><a href="datastructure/segmenttree/./fenwick/fenwick.html">Fenwick Tree</a></li>
<li><a href="datastructure/segmenttree/./mergesorttree/mergesorttree.html">Merge Sort Tree</a></li>
<li><a href="datastructure/segmenttree/./dynamicsegmenttree/dynamicsegmenttree.html">Dynamic Segment Tree</a></li>
<li><a href="datastructure/segmenttree/./lazypropagation/lazypropagation.html">Lazy Propagation</a></li>
</ul>
<h1><a class="header" href="#fenwick-tree" id="fenwick-tree">Fenwick Tree</a></h1>
<h2><a class="header" href="#소개-33" id="소개-33">1. 소개</a></h2>
<p>펜윅 트리는 구간 트리의 한 종류입니다. 주로 구간 합을 빠르게 구할 때 사용되고 BIT(Binary Indexed Tree)라고도 불립니다. 펜윅 트리는 기존의 구간 합을 구할 때 사용항였던 구간 트리인 세그먼트 트리 등에서 미리 계산하여 저장한 정보들 중 많은 양의 정보가 실제로 필요하지 않다는 점을 이용합니다. 부분 합(1번째 원소부터의 합)을 구할 때 필요한 정보들만을 계산하여 부분 합을 구하여 <code>s</code>부터 <code>e</code>까지의 구간 합을 계산한다고 하면 <code>e</code>까지의 부분 합에서 <code>s-1</code>까지의 부분 합을 빼서 구간 합을 구합니다. 기존의 세그먼트 트리에서 부분 합을 구할 때 각 노드의 오른쪽 자식은 필요로 하지 않습니다. 부모와 왼쪽 자식을 안다면 오른쪽 자식의 값도 알 수 있기 때문입니다. 필요 없는 정보들이 차지한 공간을 제외한 펜윅 트리는 다음 그림과 같습니다.</p>
<h1><a class="header" href="#merge-sort-tree" id="merge-sort-tree">Merge Sort Tree</a></h1>
<h2><a class="header" href="#소개-34" id="소개-34">1. 소개</a></h2>
<p>머지 소트 트리란 특수한 세그먼트 트리의 일종으로,  병합 정렬에서 정렬하는  과정이 그대로 트리의 노드에 저장된 트리를 말합니다 (<a href="datastructure/segmenttree/mergesorttree/../segmenttree.html">세그먼트 트리</a>, <a href="datastructure/segmenttree/mergesorttree/../../../algorithm/sort/mergesort.html">머지 소트</a> 참고). 다음 그림은 머지 소트 과정의 예시입니다. </p>
<img src="datastructure/segmenttree/mergesorttree/./mergesorttree1.png" width = 500 >
<p>머지 소트 트리는 위 과정에서 나타난 각각의 배열들을 노드로 삼아 만들어지는 트리입니다. 우리는 저 과정에서 나타난 배열들을 저장해서 새로운 트리를 만드는 것으로, 전체 수열의 부분수열에 대한 탐색을 매우 빠른 속도로 탐색할 수 있습니다. 머지 소트 트리를 만드는 것으로, 어떤 구간을 최대\(\log n\)개의 정렬된 구간으로 나타낼 수 있게 해줍니다. 위 그림의 머지 소트 과정을 활용하여 머지 소트 트리를 만든 결과는 다음과 같습니다.</p>
<img src="datastructure/segmenttree/mergesorttree/./mergesorttree2.jpg" width = 500 >
<p>가장 효율적인 정렬 알고리즘은 \(O(n\log n)\)의 시간 복잡도를 가지며, 머지 소트 역시 이런 효율적인 알고리즘중 하나입니다. 그리고 머지 소트 트리는 이런 머지 소트와 매우 유사합니다. 하나의 노드는 일반적인 세그먼트 트리와 같게 최대 두개까지의 자식 노드를 갖고, 두 노드의 배열을 합친 배열을 정렬하여 값으로 가집니다. 이런 과정을 통해 만들어진 전체 트리에서, 같은 깊이의 노드들의 배열을 전부 합치면 처음의 전체 배열에 속하는 배열이 만들어집니다. 하나의 깊이에 대해서 \(O(n)\)의 공간복잡도를 가지고, 깊이는 최대 \(\log n\)까지 존재하므로 총 \(O(n\log n)\)의 공간복잡도를 가집니다. 단순히 머지 소트에서 확인했던 노드들을 저장해두는 과정을 통해 만들어지기 때문에 머지 소트와 동일한 \(O(n\log n)\)의 시간복잡도를 가집니다. </p>
<h2><a class="header" href="#코드-10" id="코드-10">2. 코드</a></h2>
<p>머지 소트 트리를 c++코드를 통해 구현하면 아래와 같습니다.</p>
<pre><code class="language-c++">#include&lt;bits/stdc++.h&gt;
using namespace std;
const int Max = 987654321;
int MST[20][150000];

int init(int layer, int i)
{
    if(!layer)return 0;
    init(layer-1, i*2);
    init(layer-1, i*2+1);
    int j, m = 1&lt;&lt;layer, l = i*m, r = i*m+m/2;
    for(j = 0; j &lt; m; j++)
    {
        if((MST[layer-1][l] &lt; MST[layer-1][r] &amp;&amp; l &lt; i*m+m/2) || r == i*m+m)
            MST[layer][i*m+j] = MST[layer-1][l++];
        else
            MST[layer][i*m+j] = MST[layer-1][r++];
    }
    return 0;
}

int main()
{
    int i = 0, n, m, s = 0, j;
    scanf(&quot;%d %d&quot;, &amp;n, &amp;m);
    for(i = n-1; i &gt; 0; i /= 2)s++;
    for(i = 0; i &lt; n; i++)scanf(&quot;%d&quot;, &amp;MST[0][i]);
    for(i = n; i &lt; 1&lt;&lt;s; i++)MST[0][i] = Max;
    init(s, 0);
    return 0;
}
</code></pre>
<p>머지 소트 트리는 실행시간이 작지만, 그 특성상 업데이트는 시간복잡도로 인해서 커다란 의미를 가지지는 않습니다. 하나의 값을 업데이트하기 위해서는 그 값을 포함하는 \(\log n\)개의 노드를 모두 업데이트해야 하고, 업데이트에는 최대 그 노드의 길이만큼의 시간이 걸립니다. \(\log n\)개의 노드의 길이는 \(n, [n/2], ..., 1\)이므로, 그 합은 \(O(n)\)의  시간복잡도를 가지게 되어 머지 소드 트리가 아닌 일반 배열과도 시간복잡도가 같습니다.</p>
<h2><a class="header" href="#예시-5" id="예시-5">3. 예시</a></h2>
<p>그럼 이제 머지 소트 트리를 활용해서 어떤 구간에서 <code>k</code>번째로 작은 수를 구하는 문제를 풀어보도록 합시다. 별다른 알고리즘을 사용하지 않고, 구간을 복사해서 정렬하면 \(O(n\log n)\)의 시간복잡도만에 원하는 답을 구해낼 수 있습니다. 그리고 머지 소트 트리를 만들어서 활용하면 이보다 시간 복잡도를 많이 줄일 수 있습니다.</p>
<p>단순히 머지 소트 트리만을 활용한다면, 요구받은 구간을 나눈 \(\log n\)개의 정렬된 부분에서, 각 부분의 맨 앞에 있는 \(\log n\)개의 값들중 작은 값부터 빼내는 것으로 \(O(k\log n)\)의 시간복잡도를 가질 수 있습니다.</p>
<p>파라마트릭 서치(Parametric Search)와 이진탐색(Binary Search)를 활용하면 \(O(log^{3}n)\)의 시간복잡도를 가지고 원하는 답을 구해낼 수 있습니다. 어떤 수 <code>k</code>가 정해졌을 때, 요구받은 구간에서 그 수가 몇번째인지 \(O(log^{2}n)\)만에 구할 수 있습니다. 모든 부분구간들은 정렬되어 있으므로, <code>lower bound</code>를 활용하면 한 부분구간에 대해서 \(O(\log n)\)만에 구할 수 있습니다. 확인해야 하는 부분구간의 수는 최대 \(\log n\)개 이므로 어떤 수 <code>k</code>에 대해서 총 \(O(\log^{2} n)$의 시간복잡도만에 <code>k</code>가 주어진 구간에서 몇번째 수인지를 알 수 있으며, 파라마트릭 서치를 사용하면 전체 시간복잡도는 \(O(log^{3}n)\)이 됩니다. 위 알고리즘을 코드로 구현하면 아래와 같습니다.</p>
<pre><code class="language-c++">#include&lt;bits/stdc++.h&gt;
using namespace std;
const int Max = 987654321;
int MST[20][150000];

int init(int layer, int i)
{
    if(!layer)return 0;
    init(layer-1, i*2); init(layer-1, i*2+1);
    int j, m = 1&lt;&lt;layer, l = i*m, r = i*m+m/2;
    for(j = 0; j &lt; m; j++)
    {
        if((MST[layer-1][l] &lt; MST[layer-1][r] 
            &amp;&amp; l &lt; i*m+m/2) || r == i*m+m)
            MST[layer][i*m+j] = MST[layer-1][l++];
        else MST[layer][i*m+j] = MST[layer-1][r++];
    }
}

int p(int f, int l, int L, int R, int k, int i)
{
    if(l &lt;= L)return 0;
    if(f &gt;= R)return 0;
    if(f &lt;= L &amp;&amp; l &gt;= R)return lower_bound(MST[i]+L, MST[i]+R, k)-MST[i]-L;
    int mid = (L+R)/2;
    return p(f, l, L, mid, k, i-1)+p(f, l, mid, R, k, i-1);
}

int main()
{
    int i = 0, n, m, s = 0, j;
    scanf(&quot;%d %d&quot;, &amp;n, &amp;m);
    for(i = n-1; i &gt; 0; i /= 2)s++;
    for(i = 0; i &lt; n; i++)scanf(&quot;%d&quot;, &amp;MST[0][i]);
    for(i = n; i &lt; 1&lt;&lt;s; i++)MST[0][i] = Max;
    init(s,0);
    int a, b, c, t, f = 0, l = n-1;
    scanf(&quot;%d %d %d&quot;,&amp;a,&amp;b,&amp;c);a--;
    while(f &lt; l)
    {
        t = (f+l+1)/2;
        if(p(a, b, 0, 1&lt;&lt;s, MST[s][t], s) &lt; c)f = t;
        else l = t-1;
    }
    printf(&quot;%d&quot;, MST[s][l]);
    return 0;
}
</code></pre>
<p>파라마트릭 서치와 이진탐색등을 활용하여 \(O(\log^{3}n)\)만에 k번째 수를 찾아내는 방법에 대해서 이야기했지만, 이것이 이 프로그램 전체의 시간복잡도는 아니라는 점을 유의해야 합니다. 처음 프로그램을 실행하였을 때에 \(O(\log n)\)의 시간복잡도를 가지고 머지 소트 트리를 만들어야 해서 전체의 시간복잡도는 \(O(n\log n+\log^{3}n)\)이 됩니다. </p>
<p>여기까지만 본다면 머지 소트 트리를 활용하는 이유에 대한 의문이 들 수도 있겠지만, 이런 쿼리를 여러개 처리해야만 한다면 커다란 차이가 발생하게 됩니다. 단순히 정렬을 한다면 매번 새로 정렬을 해야 해서 <code>m</code>개의 쿼리를 처리하는데에 \(O(mn\log n)\)의 시간이 들지만, 머지 소트 트리의 경우에는 처음에 트리를 만들고 나서부터는 \(O(\log^{3}n)\)의 시간복잡도를 가져 총 \(O(n\log n+m\log^{3}n)\)의 시간복잡도를 가지게 됩니다. 이런 상황에서는 둘의 실행시간 차이가 꽤 많이 발생합니다.</p>
<p>같은 머지 소트 트리라도 조금씩 차이가 존재 할 수도 있습니다. 위에 나와있는 예시 코드처럼 머지 소트를 직접 구현하면서 트리를 만들 수도 있지만, \(\log n\)개의 노드를 <code>c++</code> 내장 함수를 활용하여 하나하나 정렬하는 방식으로 훨씬 편리하게 \(O(n\log^{2}n)\)만에 트리를 만드는 것도 가능하고, <code>set</code>등을 활용하여 업데이트가 가능하게 할 수도 있습니다. 머지 소트 트리를 이해한 후에는 직접 응용할 방법에 대해서 생각해 보도록 합시다.</p>
<h1><a class="header" href="#dynamic-segment-tree" id="dynamic-segment-tree">Dynamic Segment Tree</a></h1>
<h1><a class="header" href="#lazy-propagation" id="lazy-propagation">Lazy Propagation</a></h1>
<h1><a class="header" href="#advanced-data-structure" id="advanced-data-structure">Advanced Data Structure</a></h1>
<h2><a class="header" href="#소개-35" id="소개-35">1. 소개</a></h2>
<p>고급 자료구조에서는 어려운 문제를 푸는 과정들에서 필요한 자료구조들을 다룬다. </p>
<h2><a class="header" href="#종류-9" id="종류-9">2. 종류</a></h2>
<ul>
<li><a href="datastructure/advanced/./2dseg/2dseg.html">2D Segment Tree</a></li>
<li><a href="datastructure/advanced/./pst/pst.html">Persistent Segment Tree</a></li>
<li><a href="datastructure/advanced/./splay/splay.html">Splay Tree</a></li>
<li><a href="datastructure/advanced/./linkcut/linkcut.html">Link Cut Tree</a></li>
</ul>
<h1><a class="header" href="#2d-segment-tree" id="2d-segment-tree">2D Segment Tree</a></h1>
<h1><a class="header" href="#persistent-segment-tree" id="persistent-segment-tree">Persistent Segment Tree</a></h1>
<h1><a class="header" href="#splay-tree" id="splay-tree">Splay Tree</a></h1>
<h1><a class="header" href="#link-cut-tree" id="link-cut-tree">Link Cut Tree</a></h1>
<h1><a class="header" href="#additional-topics" id="additional-topics">Additional Topics</a></h1>
<h1><a class="header" href="#nim-game" id="nim-game">Nim Game</a></h1>
<h2><a class="header" href="#알고리즘에서의-게임" id="알고리즘에서의-게임">1. 알고리즘에서의 게임</a></h2>
<p>이 챕터에서는 필승 전략 게임의 승패를 판별하는 알고리즘을 다룹니다. 조약돌 게임과 Nim 게임처럼 간단한 게임에서 시작해, 그룬디 수를 이용하여 보다 일반적인 게임에 대응하는 알고리즘을 작성하는 방법까지를 설명할 것입니다.</p>
<p>수학에서 이야기하는 게임은 대부분 다음 조건들을 만족합니다.</p>
<ul>
<li>
<p>순차적 게임: 참가자는 다음 참가자가 행동을 정하기 전에 먼저 행동합니다.</p>
</li>
<li>
<p>완전 정보 게임: 모든 참가자는 게임을 완벽하게 이해하고 있고, 게임의 진행 상황도 알 수 있기 때문에 항상 최적의 선택을 합니다. </p>
</li>
<li>
<p>동일한 상황에 대해 가능한 선택은 참가자에 관계없이 동일합니다.</p>
<p>앞으로 설명할 조약돌 게임과 Nim 게임 등이 이런 조건을 만족시키는 게임입니다. 반면 체스처럼 플레이어마다 옮길 수 있는 기물이 구분되어 있거나, 포커처럼 확률이 작용하는 게임은 이런 조건을 만족하지 않는 게임입니다.</p>
</li>
</ul>
<h2><a class="header" href="#조약돌-게임" id="조약돌-게임">2. 조약돌 게임</a></h2>
<p>조약돌 게임은 <code>N</code>개의 조약돌을 한 번에 허용된 개수만큼 가져오다가, 더 이상 가져올 조약돌이 없는 사람이 지는 게임입니다. 수학에서는 보통 두 사람이 번갈아서 하는 경우를 다루며, 이 경우 선공이 반드시 이기거나 후공이 반드시 이기게 됩니다.</p>
<p><code>N=31</code>이고, 한 번에 1개, 2개 또는 3개의 돌을 가져올 수 있는 경우를 생각해 봅시다. 이 경우 선공에게 필승 전략이 있습니다. 처음에 3개를 가져오고, 다음 차례부터는  &quot;\(4-\mbox{\ (바로 전에 후공이 가져간 개수)}\)&quot;만큼을 가져가면 됩니다. 이렇게 생각하면, <code>N</code>이 4의 배수일 때만 후공이 이길 수 있다는 것도 알 수 있습니다. 가져올 수 있는 돌의 개수가 연속된 자연수일 때 이런 식으로 전체 돌의 개수의 나머지를 유지시키는 전략은 꽤 유명합니다.</p>
<img src="additional/nimgame/./nim1.JPG" width = 400 >
<p>그렇다면 가져올 수 있는 돌의 개수가 복잡하면 어떨까요? 사실 조약돌 게임에는 항상  필승전략이 존재합니다. 다만 위처럼 간단하게 정리할 수는 없습니다. 대신 간단한 알고리즘으로, 남은 돌의 개수에 따라 선공이 반드시 이길 수 있는지, 아니면 반드시 지는지를 판단할 수 있습니다.</p>
<pre><code class="language-c++">#include &lt;iostream&gt;
using namespace std;

int arg[3] = {1,2,5};

char f(int N) {
    if(N==0) return 'L';

    char ret = 'L';

    for(int i:arg) {
        if(N-i &lt; 0)	continue;
        if(f(N-i) == 'L')	ret = 'W';
    }
    return ret;
}
</code></pre>
<p>위 코드는 한 번에 가져갈 수 있는 조약돌이 1, 2 또는 5개일 때 처음 조약돌의 개수에 따라 선공의 승패를 판단해 주는 함수입니다. 다르게 말하면, 내 차례가 시작될 때 조약돌의 개수에 따라 나의 승패를 알 수 있습니다.</p>
<p>L은 무슨 선택을 해도 선공이 지는 상황을, W는 선공이 반드시 이길 수 있는 상황을 의미합니다. 만약 내가 어떤 선택을 통해 상대방에게 L 상황을 만들어줄 수 있다면, 나는 반드시 이길 수 있는 W 상황에 있습니다. 반대로, 내가 할 수 있는 모든 선택이 상대방에게 W 상황을 만들어준다면 나는 무조건 지는 L 상황에 있습니다.</p>
<h2><a class="header" href="#nim-game-1" id="nim-game-1">3. Nim Game</a></h2>
<p>Nim 게임은 매우 유명한 수학적 게임으로, 조약돌 게임을 확장한 것으로 볼 수도 있습니다. 조약돌이 <code>K</code>개의 줄을 이루고 있고, 각각의 줄에는 \(n_{1}, n_{2}, ..., n_{K}\)개의 조약돌이 있습니다. 참가자는 한 번에 한 줄에서만 조약돌을 가져올 수 있고, 한 번에 가져올 수 있는 개수에는 제한이 없습니다(물론 아예 안 가져오는 것은 불가능합니다). 돌을 가져올 수 없는 사람이 패배합니다.</p>
<img src="additional/nimgame/./nim2.JPG" width = 400 >
<p>얼핏 보면 조약돌 게임에 비해 많이 복잡해 보입니다. 그러나 Nim 게임에서 선공의 승패를 판단하는 알고리즘은 너무나도 간단합니다.</p>
<pre><code class="language-c++">#include &lt;iostream&gt;
using namespace std;
int K;
int n[1000];

int main() {
    scanf(&quot;%d&quot;,&amp;K);
    for(int i=0; i&lt;K; i++)	scanf(&quot;%d&quot;,&amp;n[i]);
        
    int ret = n[0];
    for(int i=1; i&lt;K; i++)	n[0] ^= n[i];
    
    if(ret==0)	printf(&quot;L&quot;);
    else	printf(&quot;W&quot;);
    
    return 0;
}
</code></pre>
<p>앞에서와 같은 W,L 기호를 사용했습니다. \(n_{1}, n_{2}, ..., n_{K}\)끼리 xor 연산을 한 뒤, 결과값이 0이면 L 상황이고 그 외에는 모두 W 상황입니다. </p>
<p>이렇게 단순한 방법이 왜 성립할까요? Nim 게임과 xor 연산 사이의 관계를 이해하기 위해, <code>K</code>가 작을 때부터 살펴봅시다. </p>
<p>먼저 <code>K=1</code>일 때는, 당연히 선공의 승리입니다. 조약돌을 모두 가져가면 이깁니다. <code>K=2</code>일 때는 어떨까요? 이때는 \(n_{1}=n_{2}\)일 경우 후공이, 아닐 경우 선공이 반드시 이깁니다. \(n{1}=n{2}\)에서 선공이 먼저 돌을 가져가면, 후공은 다른 줄에서 선공과 같은 수의 돌을 가져가는 것이 필승전략입니다. \(n_{1}\neq n_{2}\) 이면, 선공은 \(n{1}=n{2}\)상황을 만들어 후공에게 넘겨서 이길 수 있습니다.
<code>K=1</code>, <code>K=2</code>일 때의 상황을 위의 xor 알고리즘으로 설명할 수 있음을 간단히 알 수 있습니다.</p>
<h2><a class="header" href="#변형된-nim-게임" id="변형된-nim-게임">4. 변형된 Nim 게임</a></h2>
<p>PS 문제에서는 때로 Nim 게임을 다양하게 변형한 문제를 제시합니다.</p>
<h2><a class="header" href="#여담-3" id="여담-3">5. 여담</a></h2>
<p>그룬디 수를 이용해 승패를 판정하는 원리와 관련된 이론으로 <a href="https://en.wikipedia.org/wiki/Sprague-Grundy_theorem#Proof">스프라그-그룬디 정리</a>가 있습니다. 조합적 게임 이론에 관심이 있거나, 이 정리의 정확한 증명을 알고 싶은 사람은 추가로 참고해 보면 좋을 것입니다.</p>
<h1><a class="header" href="#2-sat" id="2-sat">2-SAT</a></h1>
<h1><a class="header" href="#meet-in-the-middle" id="meet-in-the-middle">Meet in the Middle</a></h1>
<h1><a class="header" href="#parallel-binary-search" id="parallel-binary-search">Parallel Binary Search</a></h1>
<h1><a class="header" href="#dynamic-connectivity" id="dynamic-connectivity">Dynamic Connectivity</a></h1>
<h1><a class="header" href="#scc" id="scc">SCC</a></h1>
<h1><a class="header" href="#bcc" id="bcc">BCC</a></h1>
<h1><a class="header" href="#problem-solving-2" id="problem-solving-2">Problem Solving</a></h1>
<h1><a class="header" href="#oi" id="oi">OI</a></h1>
<h1><a class="header" href="#site" id="site">SITE</a></h1>

                    </main>
                </div>
            </div>

        </div>

        

        
        <!-- Google Analytics Tag -->
        <script type="text/javascript">
            var localAddrs = ["localhost", "127.0.0.1", ""];

            // make sure we don't activate google analytics if the developer is
            // inspecting the book locally...
            if (localAddrs.indexOf(document.location.hostname) === -1) {
                (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
                (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
                m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
                })(window,document,'script','https://www.google-analytics.com/analytics.js','ga');

                ga('create', 'UA-174669347-1', 'auto');
                ga('send', 'pageview');
            }
        </script>
        

        

        
        <script type="text/javascript">
            window.playground_copyable = true;
        </script>
        

        

        
        <script src="elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="searcher.js" type="text/javascript" charset="utf-8"></script>
        

        <script src="clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->
        

        
        
        <script type="text/javascript">
        window.addEventListener('load', function() {
            MathJax.Hub.Register.StartupHook('End', function() {
                window.setTimeout(window.print, 100);
            });
        });
        </script>
        
        

    </body>
</html>
